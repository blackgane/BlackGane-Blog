<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP 学习笔记二</title>
      <link href="/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP-语法"><a href="#PHP-语法" class="headerlink" title="PHP 语法"></a>PHP 语法</h2><h3 id="PHP-If…Else-语句"><a href="#PHP-If…Else-语句" class="headerlink" title="PHP If…Else 语句"></a>PHP If…Else 语句</h3><p>当您编写代码时，您常常需要为不同的判断执行不同的动作。您可以在代码中使用条件语句来完成此任务。</p><p>在 PHP 中，提供了下列条件语句：</p><ol><li><code>if 语句</code> - 在条件成立时执行代码</li><li><code>if...else 语句</code> - 在条件成立时执行一块代码，条件不成立时执行另一块代码</li><li><code>if...else if....else 语句</code> - 在若干条件之一成立时执行一个代码块</li><li><code>switch 语句</code> - 在若干条件之一成立时执行一个代码块</li></ol><p>语法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> 条件成立时执行的代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (条件)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> 条件成立时执行的代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    条件不成立时执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-Switch-语句"><a href="#PHP-Switch-语句" class="headerlink" title="PHP Switch 语句"></a>PHP Switch 语句</h3><p>如果您希望有选择地执行若干代码块之一，请使用 switch 语句。</p><p>语法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> label1:</span><br><span class="line">    如果 n=label1，此处代码将执行;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> label2:</span><br><span class="line">    如果 n=label2，此处代码将执行;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    如果 n 既不等于 label1 也不等于 label2，此处代码将执行;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h3><p>数组能够在单个变量中存储多个值。</p><h4 id="在-PHP-中创建数组"><a href="#在-PHP-中创建数组" class="headerlink" title="在 PHP 中创建数组"></a>在 PHP 中创建数组</h4><p>在 PHP 中，<code>array()</code> 函数用于创建数组：</p><p><code>array();</code></p><p>在 PHP 中，有三种类型的数组：</p><h4 id="数值数组-带有数字-ID-键的数组"><a href="#数值数组-带有数字-ID-键的数组" class="headerlink" title="数值数组 - 带有数字 ID 键的数组"></a>数值数组 - 带有数字 ID 键的数组</h4><p>这里有两种创建数值数组的方法：</p><ol><li>自动分配 ID 键（ID 键总是从 0 开始）：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cars=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>人工分配 ID 键：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$cars[<span class="number">0</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">$cars[<span class="number">1</span>]=<span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">$cars[<span class="number">2</span>]=<span class="string">&quot;Toyota&quot;</span>;</span><br></pre></td></tr></table></figure><p>获取数组的长度 - <code>count()</code> 函数</p><p><code>count()</code> 函数用于返回数组的长度（元素的数量）：</p><p>遍历数值数组</p><p>遍历并打印数值数组中的所有值，您可以使用 for 循环</p><h4 id="关联数组-带有指定的键的数组，每个键关联一个值"><a href="#关联数组-带有指定的键的数组，每个键关联一个值" class="headerlink" title="关联数组 - 带有指定的键的数组，每个键关联一个值"></a>关联数组 - 带有指定的键的数组，每个键关联一个值</h4><p>关联数组是使用您分配给数组的指定的键的数组。</p><p>这里有两种创建关联数组的方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$age=<span class="keyword">array</span>(<span class="string">&quot;Peter&quot;</span>=&gt;<span class="string">&quot;35&quot;</span>,<span class="string">&quot;Ben&quot;</span>=&gt;<span class="string">&quot;37&quot;</span>,<span class="string">&quot;Joe&quot;</span>=&gt;<span class="string">&quot;43&quot;</span>);</span><br></pre></td></tr></table></figure><p>or:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$age[<span class="string">&#x27;Peter&#x27;</span>]=<span class="string">&quot;35&quot;</span>;</span><br><span class="line">$age[<span class="string">&#x27;Ben&#x27;</span>]=<span class="string">&quot;37&quot;</span>;</span><br><span class="line">$age[<span class="string">&#x27;Joe&#x27;</span>]=<span class="string">&quot;43&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="多维数组-包含一个或多个数组的数组"><a href="#多维数组-包含一个或多个数组的数组" class="headerlink" title="多维数组 - 包含一个或多个数组的数组"></a>多维数组 - 包含一个或多个数组的数组</h4><p>一个数组中的值可以是另一个数组，另一个数组的值也可以是一个数组。依照这种方式，我们可以创建二维或者三维数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 二维数组:</span></span><br><span class="line">$cars = <span class="keyword">array</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="number">100</span>,<span class="number">96</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&quot;BMW&quot;</span>,<span class="number">60</span>,<span class="number">59</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">&quot;Toyota&quot;</span>,<span class="number">110</span>,<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/php/php-ref-array.html">PHP 5 Array 函数手册</a></p><h3 id="PHP-数组排序"><a href="#PHP-数组排序" class="headerlink" title="PHP 数组排序"></a>PHP 数组排序</h3><ul><li><code>sort()</code> - 对数组进行升序排列</li><li><code>rsort()</code> - 对数组进行降序排列</li><li><code>asort()</code> - 根据关联数组的值，对数组进行升序排列</li><li><code>ksort()</code> - 根据关联数组的键，对数组进行升序排列</li><li><code>arsort()</code> - 根据关联数组的值，对数组进行降序排列</li><li><code>krsort()</code> - 根据关联数组的键，对数组进行降序排列</li></ul><p>[PHP 5 Array 函数手册]<a href="https://www.runoob.com/php/php-ref-array.html">https://www.runoob.com/php/php-ref-array.html</a>)</p><h3 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h3><blockquote><p>超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。</p></blockquote><p>PHP 超级全局变量列表:</p><ul><li><code>$GLOBALS</code></li><li><code>$_SERVER</code></li><li><code>$_REQUEST</code></li><li><code>$_POST</code></li><li><code>$_GET</code></li><li><code>$_FILES</code></li><li><code>$_ENV</code></li><li><code>$_COOKIE</code></li><li><code>$_SESSION</code></li></ul><h4 id="PHP-GLOBALS"><a href="#PHP-GLOBALS" class="headerlink" title="PHP $GLOBALS"></a>PHP $GLOBALS</h4><p><code>$GLOBALS</code> 是PHP的一个超级全局变量组，在一个PHP脚本的全部作用域中都可以访问。</p><p><code>$GLOBALS</code> 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。</p><p>以下实例介绍了如何使用超级全局变量 <code>$GLOBALS</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$x = <span class="number">75</span>; </span><br><span class="line">$y = <span class="number">25</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addition</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    $GLOBALS[<span class="string">&#x27;z&#x27;</span>] = $GLOBALS[<span class="string">&#x27;x&#x27;</span>] + $GLOBALS[<span class="string">&#x27;y&#x27;</span>]; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">addition(); </span><br><span class="line"><span class="keyword">echo</span> $z; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-SERVER"><a href="#PHP-SERVER" class="headerlink" title="PHP $_SERVER"></a>PHP $_SERVER</h4><p><code>$_SERVER</code> 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。</p><p>以下实例中展示了如何使用<code>$_SERVER</code>中的元素:</p><table><thead><tr><th>元素/代码</th><th>描述</th></tr></thead><tbody><tr><td>$_SERVER[‘PHP_SELF’]</td><td>当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/test.php/foo.bar">http://example.com/test.php/foo.bar</a> 的脚本中使用 $<em>SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。__FILE_\</em> 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</td></tr><tr><td>$_SERVER[‘GATEWAY_INTERFACE’]</td><td>服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</td></tr><tr><td>$_SERVER[‘SERVER_ADDR’]</td><td>当前运行脚本所在的服务器的 IP 地址。</td></tr><tr><td>$_SERVER[‘SERVER_NAME’]</td><td>当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: <a href="http://www.runoob.com/">www.runoob.com</a>)</td></tr><tr><td>$_SERVER[‘SERVER_SOFTWARE’]</td><td>服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24)</td></tr><tr><td>$_SERVER[‘SERVER_PROTOCOL’]</td><td>请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</td></tr><tr><td>$_SERVER[‘REQUEST_METHOD’]</td><td>访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。</td></tr><tr><td>$_SERVER[‘REQUEST_TIME’]</td><td>请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)</td></tr><tr><td>$_SERVER[‘QUERY_STRING’]</td><td>query string（查询字符串），如果有的话，通过它进行页面访问。</td></tr><tr><td>$_SERVER[‘HTTP_ACCEPT’]</td><td>当前请求头中 Accept: 项的内容，如果存在的话。</td></tr><tr><td>$_SERVER[‘HTTP_ACCEPT_CHARSET’]</td><td>当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</td></tr><tr><td>$_SERVER[‘HTTP_HOST’]</td><td>当前请求头中 Host: 项的内容，如果存在的话。</td></tr><tr><td>$_SERVER[‘HTTP_REFERER’]</td><td>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。)</td></tr><tr><td>$_SERVER[‘HTTPS’]</td><td>如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。</td></tr><tr><td>$_SERVER[‘REMOTE_ADDR’]</td><td>浏览当前页面的用户的 IP 地址。</td></tr><tr><td>$_SERVER[‘REMOTE_HOST’]</td><td>浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。</td></tr><tr><td>$_SERVER[‘REMOTE_PORT’]</td><td>用户机器上连接到 Web 服务器所使用的端口号。</td></tr><tr><td>$_SERVER[‘SCRIPT_FILENAME’]</td><td>当前执行脚本的绝对路径。</td></tr><tr><td>$_SERVER[‘SERVER_ADMIN’]</td><td>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：<a href="mailto:&#x73;&#111;&#109;&#x65;&#x6f;&#x6e;&#x65;&#x40;&#114;&#x75;&#110;&#111;&#x6f;&#x62;&#46;&#99;&#111;&#x6d;">&#x73;&#111;&#109;&#x65;&#x6f;&#x6e;&#x65;&#x40;&#114;&#x75;&#110;&#111;&#x6f;&#x62;&#46;&#99;&#111;&#x6d;</a>)</td></tr><tr><td>$_SERVER[‘SERVER_PORT’]</td><td>Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。</td></tr><tr><td>$_SERVER[‘SERVER_SIGNATURE’]</td><td>包含了服务器版本和虚拟主机名的字符串。</td></tr><tr><td>$_SERVER[‘PATH_TRANSLATED’]</td><td>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。</td></tr><tr><td>$_SERVER[‘SCRIPT_NAME’]</td><td>包含当前脚本的路径。这在页面需要指向自己时非常有用。__FILE__ 常量包含当前脚本(例如包含文件)的完整路径和文件名。</td></tr><tr><td>$_SERVER[‘SCRIPT_URI’]</td><td>URI 用来指定要访问的页面。例如 “/index.html”。</td></tr></tbody></table><h4 id="PHP-REQUEST"><a href="#PHP-REQUEST" class="headerlink" title="PHP $_REQUEST"></a>PHP $_REQUEST</h4><p>PHP <code>$_REQUEST</code> 用于收集HTML表单提交的数据。</p><p>以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至&lt;form&gt;标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 <code>$_REQUEST</code> 来收集表单中的 input 字段数据:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;fname&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$name = $_REQUEST[<span class="string">&#x27;fname&#x27;</span>]; </span><br><span class="line"><span class="keyword">echo</span> $name; </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-POST"><a href="#PHP-POST" class="headerlink" title="PHP $_POST"></a>PHP $_POST</h4><p>PHP <code>$_POST</code> 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。</p><p>以下实例显示了一个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至&lt;form&gt;标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 <code>$_POST</code> 来收集表单中的 input 字段数据:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;?php echo $_SERVER[&#x27;PHP_SELF&#x27;];?&gt;&quot;</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;fname&quot;</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$name = $_POST[<span class="string">&#x27;fname&#x27;</span>]; </span><br><span class="line"><span class="keyword">echo</span> $name; </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="PHP-GET"><a href="#PHP-GET" class="headerlink" title="PHP $_GET"></a>PHP $_GET</h4><p>PHP <code>$_GET</code> 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。</p><p><code>$_GET</code> 也可以收集URL中发送的数据。</p><p>假定我们有一个包含参数的超链接HTML页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test_get.php?subject=PHP&amp;web=runoob.com&quot;</span>&gt;</span>Test $GET<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户点击链接 “Test $GET”, 参数 “subject” 和 “web” 将发送至”test_get.php”,你可以在 “test_get.php” 文件中使用 $_GET 变量来获取这些数据。</p><p>以下实例显示了 “test_get.php” 文件的代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Study &quot;</span> . $_GET[<span class="string">&#x27;subject&#x27;</span>] . <span class="string">&quot; @ &quot;</span> . $_GET[<span class="string">&#x27;web&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/php/php-forms.html">PHP表单和用户输入</a></p><h3 id="PHP-循环-While-循环"><a href="#PHP-循环-While-循环" class="headerlink" title="PHP 循环 - While 循环"></a>PHP 循环 - While 循环</h3><p>在 PHP 中，提供了下列循环语句：</p><ul><li><code>while</code> - 只要指定的条件成立，则循环执行代码块</li><li><code>do...while</code> - 首先执行一次代码块，然后在指定的条件成立时重复这个循环</li><li><code>for</code> - 循环执行代码块指定的次数</li><li><code>foreach</code> - 根据数组中每个元素来循环代码块</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $key =&gt; $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-函数"><a href="#PHP-函数" class="headerlink" title="PHP 函数"></a>PHP 函数</h3><p><a href="https://www.runoob.com/php/php-ref-array.html">PHP 5 数组函数手册</a></p><h4 id="创建-PHP-函数"><a href="#创建-PHP-函数" class="headerlink" title="创建 PHP 函数"></a>创建 PHP 函数</h4><p>函数是通过调用函数来执行的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP 函数准则：</p><ul><li>函数的名称应该提示出它的功能</li><li>函数名称以字母或下划线开头（不能以数字开头）</li></ul><h4 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h4><p>为了给函数添加更多的功能，我们可以添加参数，参数类似变量。</p><p>参数就在函数名称后面的一个括号内指定。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeName</span>(<span class="params">$fname</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $fname . <span class="string">&quot; Refsnes.&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My name is &quot;</span>;</span><br><span class="line">writeName(<span class="string">&quot;Kai Jim&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My sister&#x27;s name is &quot;</span>;</span><br><span class="line">writeName(<span class="string">&quot;Hege&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;My brother&#x27;s name is &quot;</span>;</span><br><span class="line">writeName(<span class="string">&quot;Stale&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-函数-返回值"><a href="#PHP-函数-返回值" class="headerlink" title="PHP 函数 - 返回值"></a>PHP 函数 - 返回值</h4><p>如需让函数返回一个值，请使用 return 语句。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">$x,$y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $total=$x+$y;</span><br><span class="line">    <span class="keyword">return</span> $total;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;1 + 16 = &quot;</span> . add(<span class="number">1</span>,<span class="number">16</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-魔术常量"><a href="#PHP-魔术常量" class="headerlink" title="PHP 魔术常量"></a>PHP 魔术常量</h3><p>PHP 向它运行的任何脚本提供了大量的预定义常量。</p><p><strong>不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</strong></p><p>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p><p>例如 <code>__LINE__</code> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下：</p><ol><li><code>__LINE__</code></li></ol><p>文件中的当前行号。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;这是第 &quot; &#x27;</span>  . <span class="keyword">__LINE__</span> . <span class="string">&#x27; &quot; 行&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>这是第 “ 2 ” 行</p><ol start="2"><li><code>__FILE__</code></li></ol><p>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p><p>自 PHP 4.0.2 起，<code>__FILE__</code> 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="keyword">__FILE__</span> . <span class="string">&#x27; &quot; &#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>该文件位于 “ E:\wamp\www\test\index.php ”</p><ol start="3"><li><code>__DIR__</code></li></ol><p>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p><p>它等价于 <code>dirname(__FILE__)</code>。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）</p><p>实例<br><?phpecho '该文件位于 " '  . __DIR__ . ' " ';?><br>以上实例输出结果为：</p><p>该文件位于 “ E:\wamp\www\test ”</p><ol start="4"><li><strong>FUNCTION</strong></li></ol><p>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>函数名为：test</p><ol start="5"><li><code>__CLASS__</code></li></ol><p>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。</p><p>在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <code>__CLASS__</code> 对 trait 也起作用。当用在 trait 方法中时，<code>__CLASS__</code> 是调用 trait 方法的类的名字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;类名为：&#x27;</span>  . <span class="keyword">__CLASS__</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = <span class="keyword">new</span> test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>类名为：test<br>函数名为：_print</p><ol start="6"><li><code>__TRAIT__</code></li></ol><p>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p><p>Trait 名包括其被声明的作用区域（例如 Foo\Bar）。</p><p>从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">trait</span> SayWorld &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::sayHello();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloWorld</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SayWorld</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$o = <span class="keyword">new</span> MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上例程会输出：</p><p>Hello World!</p><ol start="7"><li><code>__METHOD__</code></li></ol><p>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__METHOD__</span> ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>函数名为：test</p><ol start="8"><li><code>__NAMESPACE__</code></li></ol><p>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;命名空间为：&quot;&#x27;</span>, <span class="keyword">__NAMESPACE__</span>, <span class="string">&#x27;&quot;&#x27;</span>; <span class="comment">// 输出 &quot;MyProject&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>命名空间为：”MyProject”</p><h3 id="PHP-命名空间-namespace"><a href="#PHP-命名空间-namespace" class="headerlink" title="PHP 命名空间(namespace)"></a>PHP 命名空间(namespace)</h3><p>PHP 命名空间可以解决以下两类问题：</p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h4 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h4><p>默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。</p><p>命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间。语法格式如下；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="comment">// 定义代码在 &#x27;MyProject&#x27; 命名空间中  </span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// ... 代码 ... </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以在同一个文件中定义不同的命名空间代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>&#123;</span><br><span class="line">    <span class="title">const</span> <span class="title">CONNECT_OK</span> = 1;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">AnotherProject</span>&#123;</span><br><span class="line">    <span class="title">const</span> <span class="title">CONNECT_OK</span> = 1;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span>  </span><br></pre></td></tr></table></figure><p>将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。<strong>全局代码必须用一个不带名称的 namespace 语句加上大括号括起来</strong>，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="title">const</span> <span class="title">CONNECT_OK</span> = 1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; // 全局代码</span><br><span class="line"><span class="title">session_start</span>();</span><br><span class="line">$a = MyProject\connect();</span><br><span class="line"><span class="keyword">echo</span> MyProject\Connection::start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(encoding=<span class="string">&#x27;UTF-8&#x27;</span>); <span class="comment">//定义多个命名空间和不包含在命名空间中的代码</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="title">const</span> <span class="title">CONNECT_OK</span> = 1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123; // 全局代码</span><br><span class="line"><span class="title">session_start</span>();</span><br><span class="line">$a = MyProject\connect();</span><br><span class="line"><span class="keyword">echo</span> MyProject\Connection::start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以下代码会出现语法错误：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>; <span class="comment">// 命名空间前出现了“&lt;html&gt;” 会致命错误 -　命名空间必须是程序脚本的第一条语句</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="子命名空间"><a href="#子命名空间" class="headerlink" title="子命名空间"></a>子命名空间</h4><p>与目录和文件的关系很像，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>\<span class="title">Sub</span>\<span class="title">Level</span>;  <span class="comment">//声明分层次的单个命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CONNECT_OK = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Connect</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span>  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的例子创建了常量 MyProject\Sub\Level\CONNECT_OK，类 MyProject\Sub\Level\Connection 和函数 MyProject\Sub\Level\Connect。</p><h4 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h4><p>PHP 命名空间中的类名可以通过三种方式引用：</p><ol><li><p>非限定名称，或不包含前缀的类名称，例如 <code>$a=new foo();</code> 或 <code>foo::staticmethod();</code>。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。</p></li><li><p>限定名称,或包含前缀的名称，例如 <code>$a = new subnamespace\foo();</code> 或 <code>subnamespace\foo::staticmethod();</code>。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。</p></li><li><p>完全限定名称，或包含了全局前缀操作符的名称，例如， <code>$a = new \currentnamespace\foo();</code> 或 <code>\currentnamespace\foo::staticmethod();</code>。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。</p></li></ol><p>下面是一个使用这三种方式的实例：</p><p>file1.php 文件代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Foo</span>\<span class="title">Bar</span>\<span class="title">subnamespace</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FOO = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticmethod</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>file2.php 文件代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Foo</span>\<span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;file1.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FOO = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticmethod</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非限定名称 */</span></span><br><span class="line">foo(); <span class="comment">// 解析为函数 Foo\Bar\foo</span></span><br><span class="line">foo::staticmethod(); <span class="comment">// 解析为类 Foo\Bar\foo ，方法为 staticmethod</span></span><br><span class="line"><span class="keyword">echo</span> FOO; <span class="comment">// 解析为常量 Foo\Bar\FOO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 限定名称 */</span></span><br><span class="line">subnamespace\foo(); <span class="comment">// 解析为函数 Foo\Bar\subnamespace\foo</span></span><br><span class="line">subnamespace\foo::staticmethod(); <span class="comment">// 解析为类 Foo\Bar\subnamespace\foo,</span></span><br><span class="line">                                  <span class="comment">// 以及类的方法 staticmethod</span></span><br><span class="line"><span class="keyword">echo</span> subnamespace\FOO; <span class="comment">// 解析为常量 Foo\Bar\subnamespace\FOO</span></span><br><span class="line">                                  </span><br><span class="line"><span class="comment">/* 完全限定名称 */</span></span><br><span class="line">\Foo\Bar\foo(); <span class="comment">// 解析为函数 Foo\Bar\foo</span></span><br><span class="line">\Foo\Bar\foo::staticmethod(); <span class="comment">// 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod</span></span><br><span class="line"><span class="keyword">echo</span> \Foo\Bar\FOO; <span class="comment">// 解析为常量 Foo\Bar\FOO</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 <code>\strlen()</code> 或<code> \Exception</code> 或 <code>\INI_ALL</code>。</p><p>在命名空间内部访问全局类、函数和常量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strlen</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> INI_ALL = <span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">$a = \strlen(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// 调用全局函数strlen</span></span><br><span class="line">$b = \INI_ALL; <span class="comment">// 访问全局常量 INI_ALL</span></span><br><span class="line">$c = <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&#x27;error&#x27;</span>); <span class="comment">// 实例化全局类 Exception</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="命名空间和动态语言特征"><a href="#命名空间和动态语言特征" class="headerlink" title="命名空间和动态语言特征"></a>命名空间和动态语言特征</h4><p>PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中，动态访问元素。</p><p>example1.php 文件代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__METHOD__</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcname</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> constname = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line">$a = <span class="string">&#x27;classname&#x27;</span>;</span><br><span class="line">$obj = <span class="keyword">new</span> $a; <span class="comment">// prints classname::__construct</span></span><br><span class="line">$b = <span class="string">&#x27;funcname&#x27;</span>;</span><br><span class="line">$b(); <span class="comment">// prints funcname</span></span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">&#x27;constname&#x27;</span>), <span class="string">&quot;\n&quot;</span>; <span class="comment">// prints global</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。</p><p>动态访问命名空间的元素</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">namespacename</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__METHOD__</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcname</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>,<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> constname = <span class="string">&quot;namespaced&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;example1.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">$a = <span class="string">&#x27;classname&#x27;</span>;</span><br><span class="line">$obj = <span class="keyword">new</span> $a; <span class="comment">// 输出 classname::__construct</span></span><br><span class="line">$b = <span class="string">&#x27;funcname&#x27;</span>;</span><br><span class="line">$b(); <span class="comment">// 输出函数名</span></span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">&#x27;constname&#x27;</span>), <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果使用双引号，使用方法为 &quot;\\namespacename\\classname&quot;*/</span></span><br><span class="line">$a = <span class="string">&#x27;\namespacename\classname&#x27;</span>;</span><br><span class="line">$obj = <span class="keyword">new</span> $a; <span class="comment">// 输出 namespacename\classname::__construct</span></span><br><span class="line">$a = <span class="string">&#x27;namespacename\classname&#x27;</span>;</span><br><span class="line">$obj = <span class="keyword">new</span> $a; <span class="comment">// 输出 namespacename\classname::__construct</span></span><br><span class="line">$b = <span class="string">&#x27;namespacename\funcname&#x27;</span>;</span><br><span class="line">$b(); <span class="comment">// 输出 namespacename\funcname</span></span><br><span class="line">$b = <span class="string">&#x27;\namespacename\funcname&#x27;</span>;</span><br><span class="line">$b(); <span class="comment">// 输出 namespacename\funcname</span></span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">&#x27;\namespacename\constname&#x27;</span>), <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 namespaced</span></span><br><span class="line"><span class="keyword">echo</span> constant(<span class="string">&#x27;namespacename\constname&#x27;</span>), <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 namespaced</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="namespace关键字和-NAMESPACE-常量"><a href="#namespace关键字和-NAMESPACE-常量" class="headerlink" title="namespace关键字和__NAMESPACE__常量"></a>namespace关键字和__NAMESPACE__常量</h4><p>PHP支持两种抽象的访问当前命名空间内部元素的方法，<code>__NAMESPACE__</code> 魔术常量和namespace关键字。</p><p>常量<code>__NAMESPACE__</code>的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。</p><p>关键字 namespace 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 self 操作符。</p><p>namespace操作符，命名空间中的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">blah</span>\<span class="title">blah</span> <span class="title">as</span> <span class="title">mine</span>; <span class="comment">// see &quot;Using namespaces: importing/aliasing&quot;</span></span><br><span class="line"></span><br><span class="line">blah\mine(); <span class="comment">// calls function blah\blah\mine()</span></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">blah</span>\<span class="title">mine</span>(); <span class="comment">// calls function MyProject\blah\mine()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">func</span>(); <span class="comment">// calls function MyProject\func()</span></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">sub</span>\<span class="title">func</span>(); <span class="comment">// calls function MyProject\sub\func()</span></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">cname</span>::<span class="title">method</span>(); <span class="comment">// calls static method &quot;method&quot; of class MyProject\cname</span></span><br><span class="line">$a = <span class="keyword">new</span> <span class="keyword">namespace</span>\<span class="title">sub</span>\<span class="title">cname</span>(); <span class="comment">// instantiates object of class MyProject\sub\cname</span></span><br><span class="line">$b = <span class="keyword">namespace</span>\<span class="title">CONSTANT</span>; <span class="comment">// assigns value of constant MyProject\CONSTANT to $b</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>namespace操作符, 全局代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">func</span>(); <span class="comment">// calls function func()</span></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">sub</span>\<span class="title">func</span>(); <span class="comment">// calls function sub\func()</span></span><br><span class="line"><span class="keyword">namespace</span>\<span class="title">cname</span>::<span class="title">method</span>(); <span class="comment">// calls static method &quot;method&quot; of class cname</span></span><br><span class="line">$a = <span class="keyword">new</span> <span class="keyword">namespace</span>\<span class="title">sub</span>\<span class="title">cname</span>(); <span class="comment">// instantiates object of class sub\cname</span></span><br><span class="line">$b = <span class="keyword">namespace</span>\<span class="title">CONSTANT</span>; <span class="comment">// assigns value of constant CONSTANT to $b</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用命名空间：别名-导入"><a href="#使用命名空间：别名-导入" class="headerlink" title="使用命名空间：别名/导入"></a>使用命名空间：别名/导入</h4><p>PHP 命名空间支持 有两种使用别名或导入方式：为类名称使用别名，或为命名空间名称使用别名。</p><p>在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的三种导入方式的例子：</p><ol><li>使用use操作符导入/使用别名</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">foo</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Full</span>\<span class="title">Classname</span> <span class="title">as</span> <span class="title">Another</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的例子与 use My\Full\NSname as NSname 相同</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Full</span>\<span class="title">NSname</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入一个全局类</span></span><br><span class="line"><span class="keyword">use</span> \<span class="title">ArrayObject</span>;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> <span class="keyword">namespace</span>\<span class="title">Another</span>; <span class="comment">// 实例化 foo\Another 对象</span></span><br><span class="line">$obj = <span class="keyword">new</span> Another; <span class="comment">// 实例化 My\Full\Classname　对象</span></span><br><span class="line">NSname\subns\func(); <span class="comment">// 调用函数 My\Full\NSname\subns\func</span></span><br><span class="line">$a = <span class="keyword">new</span> <span class="built_in">ArrayObject</span>(<span class="keyword">array</span>(<span class="number">1</span>)); <span class="comment">// 实例化 ArrayObject 对象</span></span><br><span class="line"><span class="comment">// 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>一行中包含多个use语句</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Full</span>\<span class="title">Classname</span> <span class="title">as</span> <span class="title">Another</span>, <span class="title">My</span>\<span class="title">Full</span>\<span class="title">NSname</span>;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Another; <span class="comment">// 实例化 My\Full\Classname 对象</span></span><br><span class="line">NSname\subns\func(); <span class="comment">// 调用函数 My\Full\NSname\subns\func</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。</p><ol start="3"><li>导入和动态名称</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Full</span>\<span class="title">Classname</span> <span class="title">as</span> <span class="title">Another</span>, <span class="title">My</span>\<span class="title">Full</span>\<span class="title">NSname</span>;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Another; <span class="comment">// 实例化一个 My\Full\Classname 对象</span></span><br><span class="line">$a = <span class="string">&#x27;Another&#x27;</span>;</span><br><span class="line">$obj = <span class="keyword">new</span> $a;      <span class="comment">// 实际化一个 Another 对象</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。</p><ol start="4"><li>导入和完全限定名称</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">My</span>\<span class="title">Full</span>\<span class="title">Classname</span> <span class="title">as</span> <span class="title">Another</span>, <span class="title">My</span>\<span class="title">Full</span>\<span class="title">NSname</span>;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Another; <span class="comment">// 实例化 My\Full\Classname 类</span></span><br><span class="line">$obj = <span class="keyword">new</span> \Another; <span class="comment">// 实例化 Another 类</span></span><br><span class="line">$obj = <span class="keyword">new</span> Another\thing; <span class="comment">// 实例化 My\Full\Classname\thing 类</span></span><br><span class="line">$obj = <span class="keyword">new</span> \Another\thing; <span class="comment">// 实例化 Another\thing 类</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用命名空间：后备全局函数-常量"><a href="#使用命名空间：后备全局函数-常量" class="headerlink" title="使用命名空间：后备全局函数/常量"></a>使用命名空间：后备全局函数/常量</h4><p>在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称，例如：</p><ol><li>在命名空间中访问全局类</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span>\<span class="title">B</span>\<span class="title">C</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> <span class="keyword">extends</span> \<span class="title">Exception</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// $a 是类 A\B\C\Exception 的一个对象</span></span><br><span class="line">$b = <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&#x27;hi&#x27;</span>); <span class="comment">// $b 是类 Exception 的一个对象</span></span><br><span class="line"></span><br><span class="line">$c = <span class="keyword">new</span> <span class="built_in">ArrayObject</span>; <span class="comment">// 致命错误, 找不到 A\B\C\ArrayObject 类</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。</p><ol start="2"><li>命名空间中后备的全局函数/常量</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span>\<span class="title">B</span>\<span class="title">C</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> E_ERROR = <span class="number">45</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strlen</span>(<span class="params">$str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> \strlen($str) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> E_ERROR, <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 &quot;45&quot;</span></span><br><span class="line"><span class="keyword">echo</span> INI_ALL, <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 &quot;7&quot; - 使用全局常量 INI_ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> strlen(<span class="string">&#x27;hi&#x27;</span>), <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 &quot;1&quot;</span></span><br><span class="line"><span class="keyword">if</span> (is_array(<span class="string">&#x27;hi&#x27;</span>)) &#123; <span class="comment">// 输出 &quot;is not array&quot;</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;is array\n&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;is not array\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="全局空间"><a href="#全局空间" class="headerlink" title="全局空间"></a>全局空间</h4><p>如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 \ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。</p><p>使用全局空间说明</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span>\<span class="title">B</span>\<span class="title">C</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个函数是 A\B\C\fopen */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fopen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="comment">/* ... */</span></span><br><span class="line">     $f = \fopen(...); <span class="comment">// 调用全局的fopen函数</span></span><br><span class="line">     <span class="keyword">return</span> $f;</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="命名空间的顺序"><a href="#命名空间的顺序" class="headerlink" title="命名空间的顺序"></a>命名空间的顺序</h4><p>自从有了命名空间之后，最容易出错的该是使用类的时候，这个类的寻找路径是什么样的了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">A</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">B</span>\<span class="title">D</span>, <span class="title">C</span>\<span class="title">E</span> <span class="title">as</span> <span class="title">F</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"></span><br><span class="line">foo();      <span class="comment">// 首先尝试调用定义在命名空间&quot;A&quot;中的函数foo()</span></span><br><span class="line">            <span class="comment">// 再尝试调用全局函数 &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">\foo();     <span class="comment">// 调用全局空间函数 &quot;foo&quot; </span></span><br><span class="line"></span><br><span class="line">my\foo();   <span class="comment">// 调用定义在命名空间&quot;A\my&quot;中函数 &quot;foo&quot; </span></span><br><span class="line"></span><br><span class="line">F();        <span class="comment">// 首先尝试调用定义在命名空间&quot;A&quot;中的函数 &quot;F&quot; </span></span><br><span class="line">            <span class="comment">// 再尝试调用全局函数 &quot;F&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B();    <span class="comment">// 创建命名空间 &quot;A&quot; 中定义的类 &quot;B&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未找到，则尝试自动装载类 &quot;A\B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> D();    <span class="comment">// 使用导入规则，创建命名空间 &quot;B&quot; 中定义的类 &quot;D&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未找到，则尝试自动装载类 &quot;B\D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> F();    <span class="comment">// 使用导入规则，创建命名空间 &quot;C&quot; 中定义的类 &quot;E&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未找到，则尝试自动装载类 &quot;C\E&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> \B();   <span class="comment">// 创建定义在全局空间中的类 &quot;B&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未发现，则尝试自动装载类 &quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> \D();   <span class="comment">// 创建定义在全局空间中的类 &quot;D&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未发现，则尝试自动装载类 &quot;D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> \F();   <span class="comment">// 创建定义在全局空间中的类 &quot;F&quot; 的一个对象</span></span><br><span class="line">            <span class="comment">// 如果未发现，则尝试自动装载类 &quot;F&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用另一个命名空间中的静态方法或命名空间函数</span></span><br><span class="line"></span><br><span class="line">B\foo();    <span class="comment">// 调用命名空间 &quot;A\B&quot; 中函数 &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line">B::foo();   <span class="comment">// 调用命名空间 &quot;A&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法</span></span><br><span class="line">            <span class="comment">// 如果未找到类 &quot;A\B&quot; ，则尝试自动装载类 &quot;A\B&quot;</span></span><br><span class="line"></span><br><span class="line">D::foo();   <span class="comment">// 使用导入规则，调用命名空间 &quot;B&quot; 中定义的类 &quot;D&quot; 的 &quot;foo&quot; 方法</span></span><br><span class="line">            <span class="comment">// 如果类 &quot;B\D&quot; 未找到，则尝试自动装载类 &quot;B\D&quot;</span></span><br><span class="line"></span><br><span class="line">\B\foo();   <span class="comment">// 调用命名空间 &quot;B&quot; 中的函数 &quot;foo&quot; </span></span><br><span class="line"></span><br><span class="line">\B::foo();  <span class="comment">// 调用全局空间中的类 &quot;B&quot; 的 &quot;foo&quot; 方法</span></span><br><span class="line">            <span class="comment">// 如果类 &quot;B&quot; 未找到，则尝试自动装载类 &quot;B&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前命名空间中的静态方法或函数</span></span><br><span class="line"></span><br><span class="line">A\B::foo();   <span class="comment">// 调用命名空间 &quot;A\A&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法</span></span><br><span class="line">              <span class="comment">// 如果类 &quot;A\A\B&quot; 未找到，则尝试自动装载类 &quot;A\A\B&quot;</span></span><br><span class="line"></span><br><span class="line">\A\B::foo();  <span class="comment">// 调用命名空间 &quot;A&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法</span></span><br><span class="line">              <span class="comment">// 如果类 &quot;A\B&quot; 未找到，则尝试自动装载类 &quot;A\B&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>名称解析遵循下列规则：</p><ol><li>对完全限定名称的函数，类和常量的调用在编译时解析。例如 new \A\B 解析为类 A\B。</li><li>所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 A\B\C 被导入为 C，那么对 C\D\e() 的调用就会被转换为 A\B\C\D\e()。</li><li>在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 A\B 内部调用 C\D\e()，则 C\D\e() 会被转换为 A\B\C\D\e() 。</li><li>非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 A\B\C 导入为C，则 new C() 被转换为 new A\B\C() 。</li><li>在命名空间内部（例如A\B），对非限定名称的函数调用是在运行时解析的。例如对函数 foo() 的调用是这样解析的：<ol><li>在当前命名空间中查找名为 A\B\foo() 的函数</li><li>尝试查找并调用 全局(global) 空间中的函数 foo()。</li></ol></li><li>在命名空间（例如A\B）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 new C() 及 new D\E() 的解析过程： <ul><li>new C()的解析:<ol><li>在当前命名空间中查找A\B\C类。</li><li>尝试自动装载类A\B\C。</li></ol></li><li>new D\E()的解析:<ol><li>在类名称前面加上当前命名空间名称变成：A\B\D\E，然后查找该类。</li><li>尝试自动装载类 A\B\D\E。</li></ol></li></ul></li></ol><p>为了引用全局命名空间中的全局类，必须使用完全限定名称 new \C()。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 学习笔记一</title>
      <link href="/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP-概述"><a href="#PHP-概述" class="headerlink" title="PHP 概述"></a>PHP 概述</h2><h3 id="PHP-文件是什么？"><a href="#PHP-文件是什么？" class="headerlink" title="PHP 文件是什么？"></a>PHP 文件是什么？</h3><ul><li>PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码</li><li>PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器</li><li>PHP 文件的默认文件扩展名是 “.php”</li></ul><h3 id="PHP-能做什么？"><a href="#PHP-能做什么？" class="headerlink" title="PHP 能做什么？"></a>PHP 能做什么？</h3><ul><li>PHP 可以生成动态页面内容</li><li>PHP 可以创建、打开、读取、写入、关闭服务器上的文件</li><li>PHP 可以收集表单数据</li><li>PHP 可以发送和接收 cookies</li><li>PHP 可以添加、删除、修改您的数据库中的数据</li><li>PHP 可以限制用户访问您的网站上的一些页面</li><li>PHP 可以加密数据</li></ul><p>通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。</p><h3 id="PHP-服务器组件"><a href="#PHP-服务器组件" class="headerlink" title="PHP 服务器组件"></a>PHP 服务器组件</h3><ol><li>WampServer<br> 下载地址：<a href="http://www.wampserver.com/">http://www.wampserver.com/</a></li><li>XAMPP<br> 下载地址：<a href="https://www.apachefriends.org/zh_cn/index.html%E3%80%82">https://www.apachefriends.org/zh_cn/index.html。</a></li></ol><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul><li>PhpStorm 下载地址：<a href="http://www.jetbrains.com/phpstorm/download/">http://www.jetbrains.com/phpstorm/download/</a></li></ul><h2 id="PHP-语法"><a href="#PHP-语法" class="headerlink" title="PHP 语法"></a>PHP 语法</h2><p>PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。</p><h3 id="基本的-PHP-语法"><a href="#基本的-PHP-语法" class="headerlink" title="基本的 PHP 语法"></a>基本的 PHP 语法</h3><p>PHP 脚本可以放在文档中的任何位置。</p><p>PHP 脚本以 <code>&lt;?php 开始，以 ?&gt;</code> 结束：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// PHP 代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP 文件的默认文件扩展名是 “.php”。</p><p>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。</p><p>PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。</p><p>通过 PHP，有两种在浏览器输出文本的基础指令：echo 和 print。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 这是 PHP 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是</span></span><br><span class="line"><span class="comment">PHP 多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h3><p>PHP 变量规则：</p><ul><li>变量以 <code>$</code> 符号开始，后面跟着变量的名称</li><li>变量名必须以字母或者下划线字符开始</li><li>变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）</li><li>变量名不能包含空格</li><li>变量名是<strong>区分大小写</strong>的（<code>$y</code> 和 <code>$Y</code> 是两个不同的变量）</li></ul><h4 id="创建（声明）PHP-变量"><a href="#创建（声明）PHP-变量" class="headerlink" title="创建（声明）PHP 变量"></a>创建（声明）PHP 变量</h4><p>PHP 没有声明变量的命令。</p><p>变量在您第一次赋值给它的时候被创建：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10.5</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-是一门弱类型语言"><a href="#PHP-是一门弱类型语言" class="headerlink" title="PHP 是一门弱类型语言"></a>PHP 是一门弱类型语言</h4><p>在上面的实例中，我们注意到，不必向 PHP 声明该变量的数据类型。</p><p>PHP 会根据变量的值，自动把变量转换为正确的数据类型。</p><p>在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。</p><h4 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h4><p>变量的作用域是脚本中变量可被引用/使用的部分。</p><p>PHP 有四种不同的变量作用域：</p><ul><li>local</li><li>global</li><li>static</li><li>parameter</li></ul><h4 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h4><p>在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</p><p>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $y=<span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;测试函数内变量:&lt;p&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;变量 x 为: $x&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;变量 y 为: $y&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">myTest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;测试函数外变量:&lt;p&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;变量 x 为: $x&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;变量 y 为: $y&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-global-关键字"><a href="#PHP-global-关键字" class="headerlink" title="PHP global 关键字"></a>PHP global 关键字</h4><p>global 关键字用于函数内访问全局变量。</p><p>在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $x,$y;</span><br><span class="line">    $y=$x+$y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y; <span class="comment">// 输出 15</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP 将所有全局变量存储在一个名为 <code>$GLOBALS[index]</code> 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p><p>上面的实例可以写成这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $GLOBALS[<span class="string">&#x27;y&#x27;</span>]=$GLOBALS[<span class="string">&#x27;x&#x27;</span>]+$GLOBALS[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Static-作用域"><a href="#Static-作用域" class="headerlink" title="Static 作用域"></a>Static 作用域</h4><p>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。</p><p>要做到这一点，请在您第一次声明变量时使用 static 关键字：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> $x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">echo</span> $x;</span><br><span class="line">    $x++;</span><br><span class="line">    <span class="keyword">echo</span> PHP_EOL;    <span class="comment">// 换行符</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line">myTest();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后，每次调用该函数时，该变量将会保留着函数前一次被调用时的值。</p><p>注释：该变量仍然是函数的局部变量。</p><h4 id="参数作用域"><a href="#参数作用域" class="headerlink" title="参数作用域"></a>参数作用域</h4><p>参数是通过调用代码将值传递给函数的局部变量。</p><p>参数是在参数列表中声明的，作为函数声明的一部分：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params">$x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> $x;</span><br><span class="line">&#125;</span><br><span class="line">myTest(<span class="number">5</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-echo-print"><a href="#PHP-echo-print" class="headerlink" title="PHP echo/print"></a>PHP echo/print</h3><p>echo 和 print 区别：</p><ul><li><p><code>echo</code> - 可以输出一个或多个字符串</p></li><li><p><code>print</code> - 只允许输出一个字符串，返回值总为 1</p></li></ul><p>提示：<code>echo</code> 输出的速度比 <code>print</code> 快， <code>echo</code> 没有返回值，print有返回值1。</p><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p><code>echo</code> 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： <code>echo</code> 或 <code>echo()</code>。</p><ul><li>显示字符串</li></ul><p>下面的实例演示了如何使用 <code>echo</code> 命令输出字符串（字符串可以包含 HTML 标签）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello world!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;我要学 PHP!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;这是一个&quot;</span>, <span class="string">&quot;字符串，&quot;</span>, <span class="string">&quot;使用了&quot;</span>, <span class="string">&quot;多个&quot;</span>, <span class="string">&quot;参数。&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>显示变量</li></ul><p>下面的实例演示了如何使用 echo 命令输出变量和字符串：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">&quot;学习 PHP&quot;</span>;</span><br><span class="line">$txt2=<span class="string">&quot;RUNOOB.COM&quot;</span>;</span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> $txt1;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;在 $txt2 学习 PHP &quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;我车的品牌是 &#123;$cars[0]&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><p><code>print</code> 同样是一个语言结构，可以使用括号，也可以不使用括号： <code>print</code> 或 <code>print()</code>。</p><ul><li>显示字符串</li></ul><p>下面的实例演示了如何使用 <code>print</code> 命令输出字符串（字符串可以包含 HTML 标签）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;h2&gt;PHP 很有趣!&lt;/h2&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;Hello world!&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;我要学习 PHP!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>显示变量</li></ul><p>下面的实例演示了如何使用 print 命令输出变量和字符串：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">&quot;学习 PHP&quot;</span>;</span><br><span class="line">$txt2=<span class="string">&quot;RUNOOB.COM&quot;</span>;</span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> $txt1;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;在 $txt2 学习 PHP &quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;我车的品牌是 &#123;$cars[0]&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-EOF-heredoc-使用说明"><a href="#PHP-EOF-heredoc-使用说明" class="headerlink" title="PHP EOF(heredoc) 使用说明"></a>PHP EOF(heredoc) 使用说明</h3><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。</p><p>使用概述：</p><ol><li>必须后接分号，否则编译通不过。</li><li><code>EOF</code> 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</li><li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li><li>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li><li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">        &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;我的第一个段落。&lt;/p&gt;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line"><span class="comment">// 结束需要独立一行且前后不能空格</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>以 <code>&lt;&lt;&lt;EOF</code> 开始标记开始，以 <code>EOF</code> 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号 。</p></li><li><p>开始标记和结束标记相同，比如常用大写的 EOT、EOD、EOF 来表示，但是不只限于那几个(也可以用：JSON、HTML等)，只要保证开始标记和结束标记不在正文中出现即可。</p></li><li><p>位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在 heredoc 中，变量不需要用连接符 . 或 , 来拼接，如下：</p></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name=<span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">$a= <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">        &quot;abc&quot;<span class="subst">$name</span></span></span><br><span class="line"><span class="string">        &quot;123&quot;</span></span><br><span class="line"><span class="string">EOF;</span></span><br><span class="line"><span class="comment">// 结束需要独立一行且前后不能空格</span></span><br><span class="line"><span class="keyword">echo</span> $a;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-数据类型"><a href="#PHP-数据类型" class="headerlink" title="PHP 数据类型"></a>PHP 数据类型</h3><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一个字符串是一串字符的序列，就像 “Hello world!”。</p><p>你可以将任何文本放在单引号和双引号中。</p><h4 id="PHP-整型"><a href="#PHP-整型" class="headerlink" title="PHP 整型"></a>PHP 整型</h4><p>整数是一个没有小数的数字。</p><p>整数规则:</p><ul><li>整数必须至少有一个数字 (0-9)</li><li>整数不能包含逗号或空格</li><li>整数是没有小数点的</li><li>整数可以是正数或负数</li><li>整型可以用三种格式来指定：十进制， 十六进制（ 以 0x 为前缀）或八进制（前缀为 0）。</li></ul><p>在以下实例中我们将测试不同的数字。</p><p>PHP <code>var_dump()</code> 函数返回变量的数据类型和值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$x = <span class="number">5985</span>;</span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line">$x = <span class="number">-345</span>; <span class="comment">// 负数 </span></span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line">$x = <span class="number">0x8C</span>; <span class="comment">// 十六进制数</span></span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">$x = <span class="number">047</span>; <span class="comment">// 八进制数</span></span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-浮点型"><a href="#PHP-浮点型" class="headerlink" title="PHP 浮点型"></a>PHP 浮点型</h4><p>浮点数是带小数部分的数字，或是指数形式。</p><p>在以下实例中我们将测试不同的数字。 PHP <code>var_dump()</code> 函数返回变量的数据类型和值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$x = <span class="number">10.365</span>;</span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line">$x = <span class="number">2.4e3</span>;</span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>; </span><br><span class="line">$x = <span class="number">8E-5</span>;</span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-布尔型"><a href="#PHP-布尔型" class="headerlink" title="PHP 布尔型"></a>PHP 布尔型</h4><p>布尔型可以是 <code>TRUE</code> 或 <code>FALSE</code>。</p><h4 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h4><p>数组可以在一个变量中存储多个值。</p><p>在以下实例中创建了一个数组， 然后使用 PHP <code>var_dump()</code> 函数返回数组的数据类型和值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$cars=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line">var_dump($cars);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-对象"><a href="#PHP-对象" class="headerlink" title="PHP 对象"></a>PHP 对象</h4><p>对象数据类型也可以用于存储数据。</p><p>在 PHP 中，对象必须声明。</p><p>首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。</p><p>然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $color;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$color=<span class="string">&quot;green&quot;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-NULL-值"><a href="#PHP-NULL-值" class="headerlink" title="PHP NULL 值"></a>PHP NULL 值</h4><p><code>NULL</code> 值表示变量没有值。<code>NULL</code> 是数据类型为 <code>NULL</code> 的值。</p><p><code>NULL</code> 值指明一个变量是否为空值。 同样可用于数据空值和<code>NULL</code>值的区别。</p><p>可以通过设置变量值为 <code>NULL</code> 来清空变量数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">$x=<span class="literal">null</span>;</span><br><span class="line">var_dump($x);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-类型比较"><a href="#PHP-类型比较" class="headerlink" title="PHP 类型比较"></a>PHP 类型比较</h3><p>虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。</p><ul><li>松散比较：使用两个等号 == 比较，只比较值，不比较类型。</li><li>严格比较：用三个等号 === 比较，除了比较值，也比较类型。</li></ul><p>例如，”42” 是一个字符串而 42 是一个整数。FALSE 是一个布尔值而 “false” 是一个字符串。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">42</span> == <span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;1、值相等&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> PHP_EOL; <span class="comment">// 换行符</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">42</span> === <span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;2、类型相等&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;3、不相等&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><p>1、值相等</p><p>3、不相等</p><ul><li>PHP中 比较 0、false、null</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 == false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="number">0</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 === false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="number">0</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 == null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="number">0</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;0 === null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="number">0</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;false == null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="literal">false</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;false === null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="literal">false</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; == false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;0&quot;</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; === false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;0&quot;</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; == null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;0&quot;</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;0&quot; === null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;0&quot;</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; == false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;&quot;</span> == <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; === false: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;&quot;</span> === <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; == null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;&quot;</span> == <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&quot;&quot; === null: &#x27;</span>;</span><br><span class="line">var_dump(<span class="string">&quot;&quot;</span> === <span class="literal">null</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="number">0</span> === <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="number">0</span> === <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="literal">false</span> === <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="string">&quot;0&quot;</span> === <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="string">&quot;0&quot;</span> === <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span> === <span class="literal">false</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="string">&quot;&quot;</span> === <span class="literal">null</span>: <span class="keyword">bool</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/20/mltkaRjFrd72QcH.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/20/MvIJlj4pKeBtOhE.png"></p><h3 id="PHP-常量"><a href="#PHP-常量" class="headerlink" title="PHP 常量"></a>PHP 常量</h3><p>常量是一个简单值的标识符。被定义后，在脚本的其他任何地方都不能被改变。</p><p>一个常量由英文字母、下划线、和数字组成,但数字不能作为首字母出现。 (<strong>常量名不需要加 $ 修饰符</strong>)。</p><p>注意： 常量在整个脚本中都可以使用。</p><h4 id="设置-PHP-常量"><a href="#设置-PHP-常量" class="headerlink" title="设置 PHP 常量"></a>设置 PHP 常量</h4><p>设置常量，使用 <code>define()</code> 函数，函数语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> define ( <span class="keyword">string</span> $name , mixed $value [, <span class="keyword">bool</span> $case_insensitive = <span class="literal">false</span> ] )</span><br></pre></td></tr></table></figure><p>该函数有三个参数:</p><ul><li><code>name</code>：必选参数，常量名称，即标志符。</li><li><code>value</code>：必选参数，常量的值。</li><li><code>case_insensitive</code> ：可选参数，如果设置为 <code>TRUE</code>，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><p>以下实例我们创建一个 区分大小写的常量, 常量值为 “欢迎访问 Runoob.com”：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 区分大小写的常量名</span></span><br><span class="line">define(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 Runoob.com&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> GREETING;    <span class="comment">// 输出 &quot;欢迎访问 Runoob.com&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> greeting;   <span class="comment">// 输出 &quot;greeting&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以下实例我们创建一个 不区分大小写的常量, 常量值为 “欢迎访问 Runoob.com”：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 不区分大小写的常量名</span></span><br><span class="line">define(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 Runoob.com&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> greeting;  <span class="comment">// 输出 &quot;欢迎访问 Runoob.com&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常量是全局的"><a href="#常量是全局的" class="headerlink" title="常量是全局的"></a>常量是全局的</h4><p>常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</p><p>以下实例演示了在函数内使用常量，即便常量定义在函数外也可以正常使用常量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 Runoob.com&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> GREETING;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();    <span class="comment">// 输出 &quot;欢迎访问 Runoob.com&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="PHP-字符串变量"><a href="#PHP-字符串变量" class="headerlink" title="PHP 字符串变量"></a>PHP 字符串变量</h3><p>字符串变量用于存储并处理文本。</p><h4 id="PHP-并置运算符"><a href="#PHP-并置运算符" class="headerlink" title="PHP 并置运算符"></a>PHP 并置运算符</h4><p>在 PHP 中，只有一个字符串运算符。</p><p>并置运算符 (.) 用于把两个字符串值连接起来。</p><p>下面的实例演示了如何将两个字符串变量连接在一起：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$txt1=<span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">$txt2=<span class="string">&quot;What a nice day!&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> $txt1 . <span class="string">&quot; &quot;</span> . $txt2;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h4><p>有时知道字符串值的长度是很有用的。</p><p>strlen() 函数返回字符串的长度（字节数）。</p><p>下面的实例返回字符串 “Hello world!” 的长度：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> strlen(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h4><p><code>strpos()</code> 函数用于在字符串内查找一个字符或一段指定的文本。</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p><p>下面的实例在字符串 “Hello world!” 中查找文本 “world”：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> strpos(<span class="string">&quot;Hello world!&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码将输出：6</p><p>提示：在上面的实例中，字符串 “world” 的位置是 6。之所以是 6 而不是 7 的原因是，字符串中第一个字符的位置是 0，而不是 1。</p><p><a href="https://www.runoob.com/php/php-ref-string.html">PHP 5 String 函数手册</a></p><h3 id="PHP-运算符"><a href="#PHP-运算符" class="headerlink" title="PHP 运算符"></a>PHP 运算符</h3><p>在 PHP 中，赋值运算符 <code>=</code> 用于给变量赋值。</p><p>在 PHP 中，算术运算符 <code>+</code> 用于把值加在一起。</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th><th>结果</th></tr></thead><tbody><tr><td>x + y</td><td>加</td><td>x 和 y 的和</td><td>2 + 2</td><td>4</td></tr><tr><td>x - y</td><td>减</td><td>x 和 y 的差</td><td>5 - 2</td><td>3</td></tr><tr><td>x * y</td><td>乘</td><td>x 和 y 的积</td><td>5 * 2</td><td>10</td></tr><tr><td>x / y</td><td>除</td><td>x 和 y 的商</td><td>15 / 5</td><td>3</td></tr><tr><td>x % y</td><td>模（除法的余数）</td><td>x 除以 y 的余数</td><td>5 % 2<br>10 % 8<br>10 % 2</td><td>1<br>2<br>0</td></tr><tr><td>-x</td><td>取反</td><td>x取反</td><td>$x =2;<br>echo -$x;</td><td>-2</td></tr><tr><td>a . b</td><td>并置</td><td>连接两个字符串</td><td>“Hi” . “Ha”</td><td>HiHa</td></tr></tbody></table><p>PHP7+ 版本新增整除运算符 <code>intdiv()</code>，该函数返回值为第一个参数除于第二个参数的值并取整（向下取整），使用实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(intdiv(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例会输出：</p><p><code>int(3)</code></p><h4 id="PHP-赋值运算符"><a href="#PHP-赋值运算符" class="headerlink" title="PHP 赋值运算符"></a>PHP 赋值运算符</h4><p>在 PHP 中，基本的赋值运算符是 <code>=</code> 。它意味着左操作数被设置为右侧表达式的值。也就是说，<code>$x = 5</code> 的值是 5。</p><table><thead><tr><th>运算符</th><th>等同于</th><th>描述</th></tr></thead><tbody><tr><td>x = y</td><td>x = y</td><td>左操作数被设置为右侧表达式的值</td></tr><tr><td>x += y</td><td>x = x + y</td><td>加</td></tr><tr><td>x -= y</td><td>x = x - y</td><td>减</td></tr><tr><td>x *= y</td><td>x = x * y</td><td>乘</td></tr><tr><td>x /= y</td><td>x = x / y</td><td>除</td></tr><tr><td>x %= y</td><td>x = x % y</td><td>模（除法的余数）</td></tr><tr><td>a .= b</td><td>a = a . b</td><td>连接两个字符串</td></tr></tbody></table><h4 id="PHP-递增-递减运算符"><a href="#PHP-递增-递减运算符" class="headerlink" title="PHP 递增/递减运算符"></a>PHP 递增/递减运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>++ x</td><td>预递增</td><td>x 加 1，然后返回 x</td></tr><tr><td>x ++</td><td>后递增</td><td>返回 x，然后 x 加 1</td></tr><tr><td>– x</td><td>预递减</td><td>x 减 1，然后返回 x</td></tr><tr><td>x –</td><td>后递减</td><td>返回 x，然后 x 减 1</td></tr></tbody></table><h4 id="PHP-比较运算符"><a href="#PHP-比较运算符" class="headerlink" title="PHP 比较运算符"></a>PHP 比较运算符</h4><p>比较操作符可以让您比较两个值：</p><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>x == y</td><td>等于</td><td>如果 x 等于 y，则返回 true</td><td>5==8 返回 false</td></tr><tr><td>x === y</td><td>绝对等于</td><td>如果 x 等于 y，且它们类型相同，则返回 true</td><td>5===”5” 返回 false</td></tr><tr><td>x != y</td><td>不等于</td><td>如果 x 不等于 y，则返回 true</td><td>5!=8 返回 true</td></tr><tr><td>x &lt;&gt; y</td><td>不等于</td><td>如果 x 不等于 y，则返回 true</td><td>5&lt;&gt;8 返回 true</td></tr><tr><td>x !== y</td><td>绝对不等于</td><td>如果 x 不等于 y，或它们类型不相同，则返回 true</td><td>5!==”5” 返回 true</td></tr><tr><td>x &gt; y</td><td>大于</td><td>如果 x 大于 y，则返回 true</td><td>5&gt;8 返回 false</td></tr><tr><td>x &lt; y</td><td>小于</td><td>如果 x 小于 y，则返回 true</td><td>5&lt;8 返回 true</td></tr><tr><td>x &gt;= y</td><td>大于等于</td><td>如果 x 大于或者等于 y，则返回 true</td><td>5&gt;=8 返回 false</td></tr><tr><td>x &lt;= y</td><td>小于等于</td><td>如果 x 小于或者等于 y，则返回 true</td><td>5&lt;=8 返回 true</td></tr></tbody></table><h4 id="PHP-逻辑运算符"><a href="#PHP-逻辑运算符" class="headerlink" title="PHP 逻辑运算符"></a>PHP 逻辑运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>x and y</td><td>与</td><td>如果 x 和 y 都为 true，则返回 true</td><td>x=6<br>y=3<br>(x &lt; 10 and y &gt; 1) 返回 true</td></tr><tr><td>x or y</td><td>或</td><td>如果 x 和 y 至少有一个为 true，则返回 true</td><td>x=6<br>y=3<br>(x==6 or y==5) 返回 true</td></tr><tr><td>x xor y</td><td>异或</td><td>如果 x 和 y 有且仅有一个为 true，则返回 true</td><td>x=6<br>y=3<br>(x==6 xor y==3) 返回 false</td></tr><tr><td>x &amp;&amp; y</td><td>与</td><td>如果 x 和 y 都为 true，则返回 true</td><td>x=6<br>y=3<br>(x &lt; 10 &amp;&amp; y &gt; 1) 返回 true</td></tr><tr><td>x || y</td><td>或</td><td>如果 x 和 y 至少有一个为 true，则返回 true</td><td>x=6<br>y=3<br>(x==5 || y==5) 返回 false</td></tr><tr><td>! x</td><td>非</td><td>如果 x 不为 true，则返回 true</td><td>x=6<br>y=3<br>!(x==y) 返回 true</td></tr></tbody></table><h4 id="PHP-数组运算符"><a href="#PHP-数组运算符" class="headerlink" title="PHP 数组运算符"></a>PHP 数组运算符</h4><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>x + y</td><td>集合</td><td>x 和 y 的集合</td></tr><tr><td>x == y</td><td>相等</td><td>如果 x 和 y 具有相同的键/值对，则返回 true</td></tr><tr><td>x === y</td><td>恒等</td><td>如果 x 和 y 具有相同的键/值对，且顺序相同类型相同，则返回 true</td></tr><tr><td>x != y</td><td>不相等</td><td>如果 x 不等于 y，则返回 true</td></tr><tr><td>x &lt;&gt; y</td><td>不相等</td><td>如果 x 不等于 y，则返回 true</td></tr><tr><td>x !== y</td><td>不恒等</td><td>如果 x 不等于 y，则返回 true</td></tr></tbody></table><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>另一个条件运算符是 <code>?:</code>（或三元）运算符 。</p><p>语法格式<br><code>(expr1) ? (expr2) : (expr3)</code></p><p>自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 <code>expr1 ?: expr3</code> 在 <code>expr1</code> 求值为 <code>TRUE</code> 时返回 <code>expr1</code>，否则返回 <code>expr3</code>。</p><h4 id="组合比较符-PHP7"><a href="#组合比较符-PHP7" class="headerlink" title="组合比较符(PHP7+)"></a>组合比较符(PHP7+)</h4><p>PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 <code>&lt;=&gt;</code>。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。</p><p>语法格式如下：</p><p><code>$c = $a &lt;=&gt; $b;</code></p><p>解析如下：</p><ul><li>如果 <code>$a &gt; $b</code>, 则 <code>$c</code> 的值为 1。</li><li>如果 <code>$a == $b</code>, 则 <code>$c</code> 的值为 0。</li><li>如果 <code>$a &lt; $b</code>, 则 <code>$c</code> 的值为 -1。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 整型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1</span> &lt;=&gt; <span class="number">2</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2</span> &lt;=&gt; <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 浮点型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">1.5</span> &lt;=&gt; <span class="number">2.5</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="number">2.5</span> &lt;=&gt; <span class="number">1.5</span>; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;a&quot;</span> &lt;=&gt; <span class="string">&quot;a&quot;</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;a&quot;</span> &lt;=&gt; <span class="string">&quot;b&quot;</span>; <span class="comment">// -1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;b&quot;</span> &lt;=&gt; <span class="string">&quot;a&quot;</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。</p><p>说明：左 ＝ 从左到右，右 ＝ 从右到左。</p><table><thead><tr><th>结合方向</th><th>运算符</th><th>附加信息</th></tr></thead><tbody><tr><td>无</td><td>clone new</td><td>clone 和 new</td></tr><tr><td>左</td><td>[</td><td>array()</td></tr><tr><td>右</td><td>++ – ~ (int) (float) (string) (array) (object) (bool) @</td><td>类型和递增／递减</td></tr><tr><td>无</td><td>instanceof</td><td>类型</td></tr><tr><td>右</td><td>!</td><td>逻辑运算符</td></tr><tr><td>左</td><td>* / %</td><td>算术运算符</td></tr><tr><td>左</td><td>+ – .</td><td>算术运算符和字符串运算符</td></tr><tr><td>左</td><td>&lt;&lt; &gt;&gt;</td><td>位运算符</td></tr><tr><td>无</td><td>== != === !== &lt;&gt;</td><td>比较运算符</td></tr><tr><td>左</td><td>&amp;</td><td>位运算符和引用</td></tr><tr><td>左</td><td>^</td><td>位运算符</td></tr><tr><td>左</td><td>|</td><td>位运算符</td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑运算符</td></tr><tr><td>左</td><td>||</td><td>逻辑运算符</td></tr><tr><td>左</td><td>? :</td><td>三元运算符</td></tr><tr><td>右</td><td>= += -= *= /= .= %= &amp;=</td><td>= ^= &lt;&lt;= &gt;&gt;= =&gt;</td></tr><tr><td>左</td><td>and</td><td>逻辑运算符</td></tr><tr><td>左</td><td>xor</td><td>逻辑运算符</td></tr><tr><td>左</td><td>or</td><td>逻辑运算符</td></tr><tr><td>左</td><td>,</td><td>多处用到</td></tr></tbody></table><blockquote><p>运算符优先级中，or 和 ||，&amp;&amp; 和 and 都是逻辑运算符，效果一样，但是其优先级却不一样。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 优先级： &amp;&amp;  &gt;  =  &gt;  and</span></span><br><span class="line"><span class="comment">// 优先级： ||  &gt;  =  &gt;  or</span></span><br><span class="line"> </span><br><span class="line">$a = <span class="number">3</span>;</span><br><span class="line">$b = <span class="literal">false</span>;</span><br><span class="line">$c = $a <span class="keyword">or</span> $b;</span><br><span class="line">var_dump($c);<span class="comment">//这里的 $c 为 int 值3，而不是 boolean 值 true</span></span><br><span class="line">$d = $a || $b;</span><br><span class="line">var_dump($d);<span class="comment">//这里的 $d 就是 boolean 值 true </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">bool</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h4 id="括号的使用"><a href="#括号的使用" class="headerlink" title="括号的使用"></a>括号的使用</h4><p>我们通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 括号优先运算</span></span><br><span class="line">$a = <span class="number">1</span>;</span><br><span class="line">$b = <span class="number">2</span>;</span><br><span class="line">$c = <span class="number">3</span>;</span><br><span class="line">$d = $a + $b * $c;</span><br><span class="line"><span class="keyword">echo</span> $d;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">$e = ($a + $b) * $c;  <span class="comment">// 使用括号</span></span><br><span class="line"><span class="keyword">echo</span> $e;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 学习笔记三</title>
      <link href="/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2020/10/20/PHP%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP-面向对象"><a href="#PHP-面向对象" class="headerlink" title="PHP 面向对象"></a>PHP 面向对象</h2><p>对象的主要三个特性：</p><ul><li>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。</li><li>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。</li><li>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/21/KierN63ClaUXODM.png" alt="Animal"></p><h3 id="面向对象内容"><a href="#面向对象内容" class="headerlink" title="面向对象内容"></a>面向对象内容</h3><ul><li>类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li><li>对象 − 是类的实例。</li><li>成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</li><li>成员函数 − 定义在类的内部，可用于访问对象的数据。</li><li>继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li><li>父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</li><li>子类 − 一个类继承其他类称为子类，也可称为派生类。</li><li>多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</li><li>重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li><li>抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li><li>封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li><li>构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</li><li>析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</li></ul><h3 id="PHP-类定义"><a href="#PHP-类定义" class="headerlink" title="PHP 类定义"></a>PHP 类定义</h3><p>PHP 定义类通常语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phpClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $var1;</span><br><span class="line">  <span class="keyword">var</span> $var2 = <span class="string">&quot;constant string&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myfunc</span> (<span class="params">$arg1, $arg2</span>) </span>&#123;</span><br><span class="line">     [..]</span><br><span class="line">  &#125;</span><br><span class="line">  [..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>解析如下：</p><ul><li>类使用 class 关键字后加上类名定义。</li><li>类名后的一对大括号({})内可以定义变量和方法。</li><li>类的变量使用 var 来声明, 变量也可以初始化值。</li><li>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</li></ul><p>变量 $this 代表自身的对象。</p><p>PHP_EOL 为换行符。</p><h3 id="PHP-构造函数"><a href="#PHP-构造函数" class="headerlink" title="PHP 构造函数"></a>PHP 构造函数</h3><p>构造函数是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。</p><p>PHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __construct ([ mixed $args [, $... ]] )</span><br></pre></td></tr></table></figure><p>在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"> $par1, $par2 </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;url = $par1;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;title = $par2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 程序编辑器</title>
      <link href="/2020/09/29/vim%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2020/09/29/vim%20%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/29/fukD7G5yRxBvEzm.png" alt="vim操作"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件与文件系统的压缩,打包与备份</title>
      <link href="/2020/09/27/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9,%E6%89%93%E5%8C%85%E4%B8%8E%E5%A4%87%E4%BB%BD/"/>
      <url>/2020/09/27/%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9,%E6%89%93%E5%8C%85%E4%B8%8E%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-系统常见的压缩指令"><a href="#Linux-系统常见的压缩指令" class="headerlink" title="Linux 系统常见的压缩指令"></a>Linux 系统常见的压缩指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*.Z compress 程序压缩的文件；</span><br><span class="line">*.zip zip 程序压缩的文件；</span><br><span class="line">*.gz gzip 程序压缩的文件；</span><br><span class="line">*.bz2 bzip2 程序压缩的文件；</span><br><span class="line">*.xz xz 程序压缩的文件；</span><br><span class="line">*.tar tar 程序打包的数据，并没有压缩过；</span><br><span class="line">*.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩</span><br><span class="line">*.tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩</span><br><span class="line">*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩</span><br></pre></td></tr></table></figure><h3 id="gzip-zcat-zmore-zless-zgrep"><a href="#gzip-zcat-zmore-zless-zgrep" class="headerlink" title="gzip, zcat/zmore/zless/zgrep"></a>gzip, zcat/zmore/zless/zgrep</h3><p>gzip 可以说是应用度最广的压缩指令了！目前 gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件。 至于 gzip 所创建的压缩文件为 *.gz 的文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ gzip [-cdtv<span class="comment">#] 文件名</span></span><br><span class="line">[dmtsai@study ~]$ zcat 文件名.gz</span><br><span class="line">选项与参数：</span><br><span class="line">-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；</span><br><span class="line">-d ：解压缩的参数；</span><br><span class="line">-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；</span><br><span class="line">-v ：可以显示出原文件/压缩文件的压缩比等信息；</span><br><span class="line">-<span class="comment"># ：# 为数字的意思，代表压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！默认是 -6</span></span><br></pre></td></tr></table></figure><p><code>cat/more/less</code> 可以使用不同的方式来读取纯文本文件，那个 <code>zcat/zmore/zless</code> 则可以对应于 <code>cat/more/less</code> 的方式来读取纯文本文件被压缩后的压缩文件！</p><p>如果你还想要从文字压缩文件当中找数据的话，可以通过 <code>zgrep</code> 来搜寻关键字喔！而不需要将压缩文件解开才以 <code>grep</code> 进行！ 这对查询备份中的文本文件数据相当有用！</p><h3 id="bzip2-bzcat-bzmore-bzless-bzgrep"><a href="#bzip2-bzcat-bzmore-bzless-bzgrep" class="headerlink" title="bzip2, bzcat/bzmore/bzless/bzgrep"></a>bzip2, bzcat/bzmore/bzless/bzgrep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ bzip2 [-cdkzv<span class="comment">#] 文件名</span></span><br><span class="line">[dmtsai@study ~]$ bzcat 文件名.bz2</span><br><span class="line">选项与参数：</span><br><span class="line">-c ：将压缩的过程产生的数据输出到屏幕上！</span><br><span class="line">-d ：解压缩的参数</span><br><span class="line">-k ：保留原始文件，而不会删除原始的文件喔！</span><br><span class="line">-z ：压缩的参数 （默认值，可以不加）</span><br><span class="line">-v ：可以显示出原文件/压缩文件的压缩比等信息；</span><br><span class="line">-<span class="comment"># ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</span></span><br></pre></td></tr></table></figure><h3 id="xz-xzcat-xzmore-xzless-xzgrep"><a href="#xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="xz, xzcat/xzmore/xzless/xzgrep"></a>xz, xzcat/xzmore/xzless/xzgrep</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ xz [-dtlkc<span class="comment">#] 文件名</span></span><br><span class="line">[dmtsai@study ~]$ xcat 文件名.xz</span><br><span class="line">选项与参数：</span><br><span class="line">-d ：就是解压缩啊！</span><br><span class="line">-t ：测试压缩文件的完整性，看有没有错误</span><br><span class="line">-l ：列出压缩文件的相关信息</span><br><span class="line">-k ：保留原本的文件不删除～</span><br><span class="line">-c ：同样的，就是将数据由屏幕上输出的意思！</span><br><span class="line">-<span class="comment"># ：同样的，也有较佳的压缩比的意思！</span></span><br></pre></td></tr></table></figure><p>通过 <code>time [gzip|bzip2|xz] -c services &gt; services.[gz|bz2|xz]</code> 去执行运算结果，结果发现这三个指令的执行时间依序是： 0.019s, 0.042s, 0.261s， 看最后一个数字！差了 10 倍的时间耶！所以，如果你并不觉得时间是你的成本考虑，那么使用 <code>xz</code> 会比较好！如果时间是你的重要成本，那么 <code>gzip</code> 恐怕是比较适合的压缩软件喔！</p><h2 id="打包指令：-tar"><a href="#打包指令：-tar" class="headerlink" title="打包指令： tar"></a>打包指令： tar</h2><p><code>gzip, bzip2, xz</code> 也能够针对目录来进行压缩，不过， 这两个指令对目录的压缩指的是“将目录内的所有文件 “分别” 进行压缩”的动作！而不像在 Windows 的系统，可以使用类似 WinRAR 这一类的压缩软件来将好多数据“包成一个文件”的样式。</p><p><code>tar</code> 可以将多个目录或文件打包成一个大文件，同时还可以通过 <code>gzip/bzip2/xz</code> 的支持，将该文件同时进行压缩！</p><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ tar [-z|-j|-J] [cv] [-f 待创建的新文件名] filename... &lt;==打包与压缩</span><br><span class="line">[dmtsai@study ~]$ tar [-z|-j|-J] [tv] [-f 既有的 tar文件名] &lt;==察看文件名</span><br><span class="line">[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 既有的 tar文件名] [-C 目录] &lt;==解压缩</span><br><span class="line">选项与参数：</span><br><span class="line">-c ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）</span><br><span class="line">-t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；</span><br><span class="line">-x ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开</span><br><span class="line">特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。</span><br><span class="line">-z ：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz</span><br><span class="line">-j ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2</span><br><span class="line">-J ：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz</span><br><span class="line">特别留意， -z, -j, -J 不可以同时出现在一串命令行中</span><br><span class="line">-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！</span><br><span class="line">-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）</span><br><span class="line">-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">其他后续练习会使用到的选项介绍：</span><br><span class="line">-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</span><br><span class="line">-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；</span><br><span class="line">--exclude=FILE：在压缩的过程中，不要将 FILE 打包！</span><br></pre></td></tr></table></figure><p>最简单的使用 tar 就只要记忆下面的方式即可：<br>压　缩：<code>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</code><br>查　询：<code>tar -jtv -f filename.tar.bz2</code><br>解压缩：<code>tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</code></p><h4 id="将备份的数据解压缩，并考虑特定目录的解压缩动作-（-C-选项的应用）"><a href="#将备份的数据解压缩，并考虑特定目录的解压缩动作-（-C-选项的应用）" class="headerlink" title="将备份的数据解压缩，并考虑特定目录的解压缩动作 （-C 选项的应用）"></a>将备份的数据解压缩，并考虑特定目录的解压缩动作 （-C 选项的应用）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ tar -jxv -f /root/etc.tar.bz2 -C /tmp</span><br><span class="line">[root@study ~]$ ll /tmp</span><br><span class="line">....（前面省略）....</span><br><span class="line">drwxr-xr-x. 131 root root 8192 Jun 26 22:14 etc</span><br><span class="line">....（后面省略）....</span><br></pre></td></tr></table></figure><h4 id="仅解开单一文件的方法"><a href="#仅解开单一文件的方法" class="headerlink" title="仅解开单一文件的方法"></a>仅解开单一文件的方法</h4><p>使用 -jtv 找到你要的文件名，然后将该文件名解开即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1\. 先找到我们要的文件名，假设解开 shadow 文件好了：</span></span><br><span class="line">[root@study ~]$ tar -jtv -f /root/etc.tar.bz2 | grep <span class="string">&#x27;shadow&#x27;</span></span><br><span class="line">---------- root/root 721 2015-06-17 00:20 etc/gshadow</span><br><span class="line">---------- root/root 1183 2015-06-17 00:20 etc/shadow-</span><br><span class="line">---------- root/root 1210 2015-06-17 00:20 etc/shadow &lt;==这是我们要的！</span><br><span class="line">---------- root/root 707 2015-06-17 00:20 etc/gshadow-</span><br><span class="line"><span class="comment"># 先搜寻重要的文件名！其中那个 grep 是“撷取”关键字的功能！我们会在第三篇说明！</span></span><br><span class="line"><span class="comment"># 这里您先有个概念即可！那个管线 | 配合 grep 可以撷取关键字的意思！</span></span><br><span class="line"><span class="comment"># 2\. 将该文件解开！语法与实际作法如下：</span></span><br><span class="line">[root@study ~]$ tar -jxv -f 打包档.tar.bz2 待解开文件名</span><br><span class="line">[root@study ~]$ tar -jxv -f /root/etc.tar.bz2 etc/shadow</span><br><span class="line">etc/shadow</span><br><span class="line">[root@study ~]$ ll etc</span><br><span class="line">total 4</span><br><span class="line">----------. 1 root root 1210 Jun 17 00:20 shadow</span><br><span class="line"><span class="comment"># 很有趣！此时只会解开一个文件而已！不过，重点是那个文件名！你要找到正确的文件名。</span></span><br><span class="line"><span class="comment"># 在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！</span></span><br></pre></td></tr></table></figure><h4 id="打包某目录，但不含该目录下的某些文件之作法"><a href="#打包某目录，但不含该目录下的某些文件之作法" class="headerlink" title="打包某目录，但不含该目录下的某些文件之作法"></a>打包某目录，但不含该目录下的某些文件之作法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* \</span><br><span class="line">&gt; --exclude=/root/system.tar.bz2 /etc /root</span><br></pre></td></tr></table></figure><h4 id="仅备份比某个时刻还要新的文件"><a href="#仅备份比某个时刻还要新的文件" class="headerlink" title="仅备份比某个时刻还要新的文件"></a>仅备份比某个时刻还要新的文件</h4><p>某些情况下你会想要备份新的文件而已，并不想要备份旧文件！此时 <code>--newer-mtime</code> 这个选项就粉重要啦！ 其实有两个选项啦，一个是 <code>--newer</code> 另一个就是 <code>--newer-mtime</code>。</p><pre><code>1. `--newer` 表示后续的日期包含 `mtime` 与 `ctime`2. `--newer-mtime` 则仅是 `mtime` 而已！</code></pre><h4 id="基本名称：-tarfile-tarball-？"><a href="#基本名称：-tarfile-tarball-？" class="headerlink" title="基本名称： tarfile, tarball ？"></a>基本名称： tarfile, tarball ？</h4><p>如果仅是打包而已，就是 <code>tar -cv -f file.tar</code>而已，这个文件我们称呼为 tarfile</p><p>进行压缩的支持，例如 <code>tar -jcv -f file.tar.bz2</code> 时，我们就称呼为 tarball</p><h4 id="特殊应用：利用管线命令与数据流"><a href="#特殊应用：利用管线命令与数据流" class="headerlink" title="特殊应用：利用管线命令与数据流"></a>特殊应用：利用管线命令与数据流</h4><p>在 tar 的使用中，有一种方式最特殊，那就是通过标准输入输出的数据流重导向（standard input/standard output）， 以及管线命令 （pipe） 的方式，将待处理的文件一边打包一边解压缩到目标目录去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1\. 将 /etc 整个目录一边打包一边在 /tmp 解开</span></span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> /tmp</span><br><span class="line">[root@study tmp]$ tar -cvf - /etc | tar -xvf -</span><br><span class="line"><span class="comment"># 这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！</span></span><br><span class="line"><span class="comment"># 要注意的地方在于输出文件变成 - 而输入文件也变成 - ，又有一个 | 存在～</span></span><br><span class="line"><span class="comment"># 这分别代表 standard output, standard input 与管线命令啦！</span></span><br><span class="line"><span class="comment"># 简单的想法中，你可以将 - 想成是在内存中的一个设备（缓冲区）。</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们<strong>想要将 <code>/etc</code> 下面的数据直接 <code>copy</code> 到目前所在的路径，也就是 <code>/tmp</code> 下面</strong>，但是又觉得使用 <code>cp -r</code> 有点麻烦，那么就直接以这个打包的方式来打包，其中，指令里面的 - 就是表示那个被打包的文件啦！ </p><p>由于我们不想要让中间文件存在，所以就以这一个方式来进行复制的行为啦！</p><h2 id="XFS-文件系统的备份与还原"><a href="#XFS-文件系统的备份与还原" class="headerlink" title="XFS 文件系统的备份与还原"></a>XFS 文件系统的备份与还原</h2><p>CentOS 7 已经使用 XFS 文件系统作为默认值，所以那个好用的 <code>xfsdump</code><br>与 <code>xfsrestore</code> 两个工具对 CentOS 7 来说，就是挺重要的工具软件了。</p><h3 id="XFS-文件系统备份-xfsdump"><a href="#XFS-文件系统备份-xfsdump" class="headerlink" title="XFS 文件系统备份 xfsdump"></a>XFS 文件系统备份 xfsdump</h3><p><code>xfsdump</code>可以进行：</p><ul><li>全量备份</li><li>增量备份</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/29/XVU8xjp1zON49Hc.png" alt="xfsdump 运行时，完整备份与累积备份示意图"></p><p>如上图所示，上方的“实时文件系统”是一直随着时间而变化的数据，例如在 <code>/home</code> 里面的文件数据会一直变化一样。 而下面的方块则是 <code>xfsdump</code> 备份起来的数据，第一次备份一定是完整备份，完整备份在 <code>xfsdump</code> 当中被定义为 level 0 喔！等到第二次备份时，<code>/home</code> 文件系统内的数据已经与 level 0 不一样了，而 level 1 仅只是比较目前的文件系统与 level 0 之间的差异后，备份有变化过的文件而已。至于 level 2 则是与 level 1 进行比较啦！这样了解呼？至于各个 level 的纪录档则放置于 <code>/var/lib/xfsdump/inventory</code> 中。</p><p>使用 xfsdump 时，请注意下面的限制喔：</p><ul><li><code>xfsdump</code> 不支持没有挂载的文件系统备份！所以只能备份已挂载的！</li><li><code>xfsdump</code> 必须使用 root 的权限才能操作 （涉及文件系统的关系）</li><li><code>xfsdump</code> 只能备份 XFS 文件系统啊！</li><li><code>xfsdump</code> 备份下来的数据 （文件或储存媒体） 只能让 xfsrestore 解析</li><li><code>xfsdump</code> 是通过文件系统的 UUID 来分辨各个备份文件的，因此不能备份两个具有相同UUID 的文件系统喔！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfsdump [-L S_label] [-M M_label] [-l <span class="comment">#] [-f 备份文件] 待备份数据</span></span><br><span class="line">[root@study ~]$ xfsdump -I</span><br><span class="line">选项与参数：</span><br><span class="line">-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明</span><br><span class="line">-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明</span><br><span class="line">-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）</span><br><span class="line">-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等</span><br><span class="line">-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态</span><br></pre></td></tr></table></figure><h4 id="用-xfsdump-进行累积备份-（Incremental-backups）"><a href="#用-xfsdump-进行累积备份-（Incremental-backups）" class="headerlink" title="用 xfsdump 进行累积备份 （Incremental backups）"></a>用 xfsdump 进行累积备份 （Incremental backups）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot</span><br></pre></td></tr></table></figure><h3 id="XFS-文件系统还原-xfsrestore"><a href="#XFS-文件系统还原-xfsrestore" class="headerlink" title="XFS 文件系统还原 xfsrestore"></a>XFS 文件系统还原 xfsrestore</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfsrestore -I &lt;==用来察看备份文件数据</span><br><span class="line">[root@study ~]$ xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &lt;==单一文件全系统复原</span><br><span class="line">[root@study ~]$ xfsrestore [-f 备份文件] -r 待复原目录 &lt;==通过累积备份文件来复原系统</span><br><span class="line">[root@study ~]$ xfsrestore [-f 备份文件] -i 待复原目录 &lt;==进入互动模式</span><br><span class="line">选项与参数：</span><br><span class="line">-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等</span><br><span class="line">-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！</span><br><span class="line">-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！</span><br><span class="line">-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！</span><br><span class="line">-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，</span><br><span class="line">需要这东西来达成累积复原</span><br><span class="line">-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！</span><br></pre></td></tr></table></figure><h4 id="用-xfsrestore-观察-xfsdump-后的备份数据内容"><a href="#用-xfsrestore-观察-xfsdump-后的备份数据内容" class="headerlink" title="用 xfsrestore 观察 xfsdump 后的备份数据内容"></a>用 xfsrestore 观察 xfsdump 后的备份数据内容</h4><ol><li>找出 <code>xfsdump</code> 的内容就使用 <code>xfsrestore -I</code> 来查阅即可！不需要加任何参数！</li></ol><h4 id="简单复原-level-0-的文件系统"><a href="#简单复原-level-0-的文件系统" class="headerlink" title="简单复原 level 0 的文件系统"></a>简单复原 level 0 的文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1\. 直接将数据给它覆盖回去即可！</span></span><br><span class="line">[root@study ~]$ xfsrestore -f /srv/boot.dump -L boot_all /boot</span><br><span class="line">xfsrestore: using file dump （drive_simple） strategy</span><br><span class="line">xfsrestore: version 3.1.4 （dump format 3.0） - <span class="built_in">type</span> ^C <span class="keyword">for</span> status and control</span><br><span class="line">xfsrestore: using online session inventory</span><br><span class="line">xfsrestore: searching media <span class="keyword">for</span> directory dump</span><br><span class="line">xfsrestore: examining media file 0</span><br><span class="line">xfsrestore: reading directories</span><br><span class="line">xfsrestore: 8 directories and 327 entries processed</span><br><span class="line">xfsrestore: directory post-processing</span><br><span class="line">xfsrestore: restoring non-directory files</span><br><span class="line">xfsrestore: restore complete: 1 seconds elapsed</span><br><span class="line">xfsrestore: Restore Summary:</span><br><span class="line">xfsrestore: stream 0 /srv/boot.dump OK （success） <span class="comment"># 是否是正确的文件啊？</span></span><br><span class="line">xfsrestore: Restore Status: SUCCESS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2\. 将备份数据在 /tmp/boot 下面解开！</span></span><br><span class="line">[root@study ~]$ mkdir /tmp/boot</span><br><span class="line">[root@study ~]$ xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot</span><br><span class="line">[root@study ~]$ du -sm /boot /tmp/boot</span><br><span class="line">109 /boot</span><br><span class="line">99 /tmp/boot</span><br><span class="line"><span class="comment"># 咦！两者怎么大小不一致呢？没关系！我们来检查看看！</span></span><br><span class="line">[root@study ~]$ diff -r /boot /tmp/boot</span><br><span class="line">Only <span class="keyword">in</span> /boot: testing.img</span><br><span class="line"><span class="comment"># 看吧！原来是 /boot 我们有增加过一个文件啦！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3\. 仅复原备份文件内的 grub2 到 /tmp/boot2/ 里头去！</span></span><br><span class="line">[root@study ~]$ mkdir /tmp/boot2</span><br><span class="line">[root@study ~]$ xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2</span><br></pre></td></tr></table></figure><blockquote><p>如果只想要复原某一个目录或文件的话，直接加上 <code>-s 目录</code> 这个选项与参数即可</p></blockquote><h4 id="复原累积备份数据"><a href="#复原累积备份数据" class="headerlink" title="复原累积备份数据"></a>复原累积备份数据</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继续复原 level 1 到 /tmp/boot 当中！</span></span><br><span class="line">[root@study ~]$ xfsrestore -f /srv/boot.dump1 /tmp/boot</span><br></pre></td></tr></table></figure><h4 id="仅还原部分文件的-xfsrestore-互动模式"><a href="#仅还原部分文件的-xfsrestore-互动模式" class="headerlink" title="仅还原部分文件的 xfsrestore 互动模式"></a>仅还原部分文件的 xfsrestore 互动模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1\. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！</span></span><br><span class="line">[root@study ~]$ mkdir /tmp/boot3</span><br><span class="line">[root@study ~]$ xfsrestore -f /srv/boot.dump -i /tmp/boot3</span><br><span class="line">========================== subtree selection dialog ==========================</span><br><span class="line">the following commands are available:</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">ls [ &lt;path&gt; ]</span><br><span class="line"><span class="built_in">cd</span> [ &lt;path&gt; ]</span><br><span class="line">add [ &lt;path&gt; ] <span class="comment"># 可以加入复原文件列表中</span></span><br><span class="line">delete [ &lt;path&gt; ] <span class="comment"># 从复原列表拿掉文件名！并非删除喔！</span></span><br><span class="line">extract <span class="comment"># 开始复原动作！</span></span><br><span class="line">quit</span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">&gt; ls</span><br><span class="line">455517 initramfs-3.10.0-229.el7.x86_64kdump.img</span><br><span class="line">138 initramfs-3.10.0-229.el7.x86_64.img</span><br><span class="line">141 initrd-plymouth.img</span><br><span class="line">140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a</span><br><span class="line">139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img</span><br><span class="line">137 vmlinuz-3.10.0-229.el7.x86_64</span><br><span class="line">136 symvers-3.10.0-229.el7.x86_64.gz</span><br><span class="line">135 config-3.10.0-229.el7.x86_64</span><br><span class="line">134 System.map-3.10.0-229.el7.x86_64</span><br><span class="line">133 .vmlinuz-3.10.0-229.el7.x86_64.hmac</span><br><span class="line">1048704 grub2/</span><br><span class="line">131 grub/</span><br><span class="line">&gt; add grub</span><br><span class="line">&gt; add grub2</span><br><span class="line">&gt; add config-3.10.0-229.el7.x86_64</span><br><span class="line">&gt; extract</span><br><span class="line">[root@study ~]$ ls -l /tmp/boot3</span><br><span class="line">-rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64</span><br><span class="line">drwxr-xr-x. 2 root root 26 May 4 17:52 grub</span><br><span class="line">drwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2</span><br><span class="line"><span class="comment"># 就只会有 3 个文件名被复原，当然，如果文件名是目录，那下面的子文件当然也会被还原回来的！</span></span><br></pre></td></tr></table></figure><h2 id="光盘写入工具"><a href="#光盘写入工具" class="headerlink" title="光盘写入工具"></a>光盘写入工具</h2><ul><li>先将所需要备份的数据创建成为一个镜像文件（iso），利用 mkisofs 指令来处理；</li><li>将该镜像文件烧录至光盘或 DVD 当中，利用 cdrecord 指令来处理。</li></ul><h3 id="mkisofs：创建镜像文件"><a href="#mkisofs：创建镜像文件" class="headerlink" title="mkisofs：创建镜像文件"></a>mkisofs：创建镜像文件</h3><h4 id="制作一般数据光盘镜像文件"><a href="#制作一般数据光盘镜像文件" class="headerlink" title="制作一般数据光盘镜像文件"></a>制作一般数据光盘镜像文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mkisofs [-o 镜像文件] [-Jrv] [-V vol] [-m file] 待备份文件... \</span><br><span class="line">&gt; -graft-point isodir=systemdir ...</span><br><span class="line">选项与参数：</span><br><span class="line">-o ：后面接你想要产生的那个镜像文件文件名。</span><br><span class="line">-J ：产生较相容于 windows 机器的文件名结构，可增加文件名长度到 64 个 unicode 字符</span><br><span class="line">-r ：通过 Rock Ridge 产生支持 Unix/Linux 的文件数据，可记录较多的信息（如 UID/GID等） ；</span><br><span class="line">-v ：显示创建 ISO文件的过程</span><br><span class="line">-V vol ：创建 Volume，有点像 Windows 在文件资源管理器内看到的 CD title 的东西</span><br><span class="line">-m file ：-m 为排除文件 （exclude） 的意思，后面的文件不备份到镜像文件中，也能使用 * 万用字符喔</span><br><span class="line">-graft-point：graft有转嫁或移植的意思，相关数据在下面文章内说明。</span><br></pre></td></tr></table></figure><h2 id="其他常见的压缩与备份工具"><a href="#其他常见的压缩与备份工具" class="headerlink" title="其他常见的压缩与备份工具"></a>其他常见的压缩与备份工具</h2><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p><code>dd</code> 可备份完整的 partition 或 disk ，因为 dd 可读取磁盘的 sector 表面数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ dd <span class="keyword">if</span>=<span class="string">&quot;input_file&quot;</span> of=<span class="string">&quot;output_file&quot;</span> bs=<span class="string">&quot;block_size&quot;</span> count=<span class="string">&quot;number&quot;</span></span><br><span class="line">选项与参数：</span><br><span class="line"><span class="keyword">if</span> ：就是 input file 啰～也可以是设备喔！</span><br><span class="line">of ：就是 output file 喔～也可以是设备；</span><br><span class="line">bs ：规划的一个 block 的大小，若未指定则默认是 512 Bytes（一个 sector 的大小）</span><br><span class="line">count：多少个 bs 的意思。</span><br></pre></td></tr></table></figure><blockquote><p>你想要创建两颗一模一样的磁盘时， 只要下达类似： <code>dd if=/dev/sda of=/dev/sdb</code> ，就能够让两颗磁盘一模一样，甚至 <code>/dev/sdb</code> 不需要分区与格式化， 因为该指令可以将 <code>/dev/sda</code> 内的所有数据，包括 MBR 与 partition table 也复制到 <code>/dev/sdb</code> 说！</p></blockquote><h3 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h3><p><code>cpio</code> 为相当优秀的备份指令，不过必须要搭配类似 <code>find</code> 指令来读入欲备份的文件名数据，方可进行备份动作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ cpio -ovcB &gt; [file|device] &lt;==备份</span><br><span class="line">[root@study ~]$ cpio -ivcdu &lt; [file|device] &lt;==还原</span><br><span class="line">[root@study ~]$ cpio -ivct &lt; [file|device] &lt;==察看</span><br><span class="line">备份会使用到的选项与参数：</span><br><span class="line">-o ：将数据 copy 输出到文件或设备上</span><br><span class="line">-B ：让默认的 Blocks 可以增加至 5120 Bytes ，默认是 512 Bytes ！</span><br><span class="line">　 　这样的好处是可以让大文件的储存速度加快（请参考 i-nodes 的观念）</span><br><span class="line">还原会使用到的选项与参数：</span><br><span class="line">-i ：将数据自文件或设备 copy 出来系统当中</span><br><span class="line">-d ：自动创建目录！使用 cpio 所备份的数据内容不见得会在同一层目录中，因此我们</span><br><span class="line">必须要让 cpio 在还原时可以创建新目录，此时就得要 -d 选项的帮助！</span><br><span class="line">-u ：自动的将较新的文件覆盖较旧的文件！</span><br><span class="line">-t ：需配合 -i 选项，可用在<span class="string">&quot;察看&quot;</span>以 cpio 创建的文件或设备的内容</span><br><span class="line">一些可共享的选项与参数：</span><br><span class="line">-v ：让储存的过程中文件名称可以在屏幕上显示</span><br><span class="line">-c ：一种较新的 portable format 方式储存</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 压缩 </tag>
            
            <tag> 打包 </tag>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 磁盘与文件系统管理</title>
      <link href="/2020/09/17/Linux%20%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2020/09/17/Linux%20%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="认识-Linux-文件系统"><a href="#认识-Linux-文件系统" class="headerlink" title="认识 Linux 文件系统"></a>认识 Linux 文件系统</h2><h3 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h3><blockquote><p>例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 （superblock） 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p></blockquote><p>每个 inode 与 block 都有编号，至于这三个数据的意义可以简略说明如下：</p><ul><li><p>superblock：记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</p></li><li><p>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block号码；</p></li><li><p>block：实际记录文件的内容，若文件太大时，会占用多个 block 。</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/17/AmEJRXwpNFbxrO9.png" alt="inode/block 数据存取示意图"></p><p>某一个文件的属性与权限数据是放置到 inode 4 号（下图较小方格内），而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码</p><p>这种数据存取的方法我们称为索引式文件系统（indexed allocation）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/17/Rxio5SeFJg7TBHQ.png" alt="FAT文件系统数据存取示意图"></p><p>文件的数据依序写入1-&gt;7-&gt;4-&gt;15号这四个 block 号码中， 但这个文件系统没<br>有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！</p><h3 id="Linux-的-EXT2-文件系统（inode）"><a href="#Linux-的-EXT2-文件系统（inode）" class="headerlink" title="Linux 的 EXT2 文件系统（inode）"></a>Linux 的 EXT2 文件系统（inode）</h3><p>Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 （block group） 的，每个区块群组都有独立的 inode/block/superblock 系统。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/17/wMy9gu8zfdFAjEk.png" alt="ext2文件系统示意图"></p><ul><li>文件系统最前面有一个开机扇区（boot sector），这个开机扇区可以安装开机管理程序</li></ul><p>每一个区块群组（block group）的六个主要内容：</p><ul><li><p>data block （数据区块）</p><p>  data block 是用来放置文件内容数据地方。</p><table><thead><tr><th>Block</th><th>大小1KB</th><th>2KB</th><th>4KB</th></tr></thead><tbody><tr><td>最大单一文件限制</td><td>16GB</td><td>256GB</td><td>2TB</td></tr><tr><td>最大文件系统总容量</td><td>2TB</td><td>8TB</td><td>16TB</td></tr></tbody></table><p>  Ext2 文件系统的 block 基本限制如下：</p><ul><li>原则上，block 的大小与数量在格式化完就不能够再改变了（除非重新格式化）；</li><li>每个 block 内最多只能够放置一个文件的数据；</li><li>承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量；</li><li>承上，<strong>若文件小于 block ，则该 block 的剩余容量就不能够再被使用了（磁盘空间会浪费）。</strong></li></ul></li><li><p>inode table （inode 表格）</p><p>  inode 是记录文件的属性以及该文件实际数据是放置在哪几个 block。</p><ul><li><p>该文件的存取模式（read/write/excute）；</p></li><li><p>该文件的拥有者与群组（owner/group）；</p></li><li><p>该文件的容量；</p></li><li><p>该文件创建或状态改变的时间（ctime）；</p></li><li><p>最近一次的读取时间（atime）；</p></li><li><p>最近修改的时间（mtime）；</p></li><li><p>定义文件特性的旗标（flag），如 SetUID…；</p></li><li><p>该文件真正内容的指向 （pointer）；</p><p>其他特点：</p></li><li><p>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）；</p></li><li><p>每个文件都仅会占用一个 inode 而已；</p></li><li><p>承上，因此文件系统能够创建的文件数量与 inode 的数量有关；</p></li><li><p>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/17/MI9rcETAbgSHy3L.png" alt="inode 结构示意图"></p><p>上图最左边为 inode 本身 （128 Bytes），里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录号码。</p></li></ul></li><li><p>Superblock （超级区块）</p><p>  Superblock 是记录整个 filesystem 相关信息的地方， 没有 Superblock ，就没有这个filesystem 了</p><p>  记录的信息主要有：</p><ul><li><p>block 与 inode 的总量；</p></li><li><p>未使用与已使用的 inode / block 数量；</p></li><li><p>block 与 inode 的大小 （block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）；</p></li><li><p>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息；</p></li><li><p>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。</p><p>此外，每个 block group 都可能含有 superblock。<br>一般除第一个block group会有superblock，后续如果有的话，就是给第一个 block group 内 superblock 的备份，以后可以做恢复使用。</p></li></ul></li><li><p>Filesystem Description（文件系统描述说明）</p><p>  这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段（superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。</p></li><li><p>block bitmap （区块对照表）</p><p>  记录的是使用与未使用的 block 号码</p></li><li><p>inode bitmap （inode 对照表）</p><p>  记录使用与未使用的 inode 号码</p></li><li><p>dumpe2fs： 查询 Ext 家族 superblock 信息的指令</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ dumpe2fs [-bh] 设备文件名</span><br><span class="line">选项与参数：</span><br><span class="line">-b ：列出保留为坏轨的部分（一般用不到吧！？）</span><br><span class="line">-h ：仅列出 superblock 的数据，不会列出其他的区段内容！</span><br></pre></td></tr></table></figure><h3 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>当我们在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码；而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。也就是说目录所占用的 block 内容在记录如下的信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/17/ZhOskPA8DruTwUq.png" alt="记载于目录所属的 block 内的文件名与 inode 号码对应示意图"></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>当我们在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。例如：假设我的一个 block 为 4 KBytes ，而我要创建一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件！ 但同时请注意，由于 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录喔！</p><h4 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ll -di / /etc /etc/passwd</span><br><span class="line">128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /</span><br><span class="line">33595521 drwxr-xr-x. 131 root root 8192 Jun 17 00:20 /etc</span><br><span class="line">36628004 -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/passwd</span><br></pre></td></tr></table></figure><p>该文件的读取流程为:</p><ol><li><code>/</code> 的 inode： 通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有 r 与 x） ；</li><li><code>/</code> 的 block： 经过上个步骤取得 block 的号码，并找到该内容有 <code>etc/</code> 目录的 inode 号码（33595521）；</li><li><code>etc/</code> 的 inode： 读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取etc/ 的 block 内容；</li><li><code>etc/</code> 的 block： 经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）；</li><li><code>passwd</code> 的 inode： 读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容；</li><li><code>passwd</code> 的 block： 最后将该 block 内容的数据读出来。</li><li>filesystem 大小与磁盘读取性能：如果文件写入的 block 真的分的很散， 此时就会有所谓的文件数据离散的问题发生了。(文件太大)</li></ol><h3 id="EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能"><a href="#EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能" class="headerlink" title="EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能"></a>EXT2/EXT3/EXT4 文件的存取与日志式文件系统的功能</h3><p>新增一个文件，此时文件系统的行为是：</p><ol><li>先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增；</li><li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入；</li><li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据；</li><li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新superblock 的内容。</li></ol><blockquote><p>inode table 与 data block 称为数据存放区域。<br>superblock、block bitmap 与 inode bitmap 等区段就被称为 metadata （中介数据），因为 superblock, inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，所以被称为中介数据。</p></blockquote><h4 id="数据的不一致-（Inconsistent）-状态"><a href="#数据的不一致-（Inconsistent）-状态" class="headerlink" title="数据的不一致 （Inconsistent） 状态"></a>数据的不一致 （Inconsistent） 状态</h4><p>意外导致文件数据的不完整。</p><h4 id="日志式文件系统-（Journaling-filesystem）"><a href="#日志式文件系统-（Journaling-filesystem）" class="headerlink" title="日志式文件系统 （Journaling filesystem）"></a>日志式文件系统 （Journaling filesystem）</h4><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li><li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li><li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li></ol><h3 id="Linux-文件系统的运行"><a href="#Linux-文件系统的运行" class="headerlink" title="Linux 文件系统的运行"></a>Linux 文件系统的运行</h3><ul><li>系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读/写；</li><li>承上，因此 Linux 的实体内存最后都会被用光！这是正常的情况！可加速系统性能；</li><li>你可以手动使用 sync 来强迫内存中设置为 Dirty 的文件回写到磁盘中；</li><li>若正常关机时，关机指令会主动调用 sync 来将内存的数据回写入磁盘内；</li><li>但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内， 因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）。</li></ul><h3 id="挂载点的意义-（mount-point）"><a href="#挂载点的意义-（mount-point）" class="headerlink" title="挂载点的意义 （mount point）"></a>挂载点的意义 （mount point）</h3><p>每个 filesystem 都有独立的 inode / block / superblock 等信息，这个文件系统要能够链接到目录树才能被我们使用。 将文件系统与目录树结合的动作我们称为“挂载”。</p><h3 id="其他-Linux-支持的文件系统与-VFS"><a href="#其他-Linux-支持的文件系统与-VFS" class="headerlink" title="其他 Linux 支持的文件系统与 VFS"></a>其他 Linux 支持的文件系统与 VFS</h3><ul><li>传统文件系统：ext2 / minix / MS-DOS / FAT （用 vfat 模块） / iso9660 （光盘）等等；</li><li>日志式文件系统： ext3 / ext4 / ReiserFS / Windows’ NTFS / IBM’s JFS / SGI’s XFS / ZFS</li><li>网络文件系统： NFS / SMBFS</li></ul><h4 id="Linux-VFS-（Virtual-Filesystem-Switch）"><a href="#Linux-VFS-（Virtual-Filesystem-Switch）" class="headerlink" title="Linux VFS （Virtual Filesystem Switch）"></a>Linux VFS （Virtual Filesystem Switch）</h4><p>整个 Linux 的系统都是通过一个名为 Virtual Filesystem Switch 的核<br>心功能去读取 filesystem 的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/21/z8IXsQYJgywE1mk.png" alt="VFS 文件系统的示意图"></p><h3 id="XFS-文件系统简介"><a href="#XFS-文件系统简介" class="headerlink" title="XFS 文件系统简介"></a>XFS 文件系统简介</h3><blockquote><p>CentOS 7 开始，默认的文件系统已经由原本的 EXT4 变成了 XFS 文件系统</p></blockquote><p>为什么要从EXT4 -&gt; XFS？</p><ul><li>EXT 家族当前较伤脑筋的地方：支持度最广，但格式化超慢！</li></ul><p>查看XFS <code>xfs_info</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfs_info 挂载点 | 设备文件名</span><br><span class="line">范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录</span><br><span class="line">[root@study ~]$ df -T /boot</span><br><span class="line">Filesystem Type 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/vda2 xfs 1038336 133704 904632 13% /boot</span><br><span class="line"><span class="comment"># 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！</span></span><br><span class="line">[root@study ~]$ xfs_info /dev/vda2</span><br><span class="line">1 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks</span><br><span class="line">2 = sectsz=512 attr=2, projid32bit=1</span><br><span class="line">3 = crc=0 finobt=0</span><br><span class="line">4 data = bsize=4096 blocks=262144, imaxpct=25</span><br><span class="line">5 = sunit=0 swidth=0 blks</span><br><span class="line">6 naming =version 2 bsize=4096 ascii-ci=0 ftype=0</span><br><span class="line">7 <span class="built_in">log</span> =internal bsize=4096 blocks=2560, version=2</span><br><span class="line">8 = sectsz=512 sunit=0 blks, lazy-count=1</span><br><span class="line">9 realtime =none extsz=4096 blocks=0, rtextents=0</span><br></pre></td></tr></table></figure><p>上面的输出讯息可以这样解释：</p><ul><li>第 1 行里面的 isize 指的是 inode 的容量，每个有 256Bytes 这么大。至于 agcount 则是前面谈到的储存区群组 （allocation group） 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设置为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！</li><li>第 2 行里面 sectsz 指的是逻辑扇区 （sector） 的容量设置为 512Bytes 这么大的意思。</li><li>第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个 block 在这个文件系统内。</li><li>第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。</li><li>第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K * 2560 个 block，总共约 10M 的容量。</li><li>第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。</li></ul><h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><ul><li><code>df</code>：列出文件系统的整体磁盘使用量；</li><li><code>du</code>：评估文件系统的磁盘使用量（常用在推估目录所占容量）</li></ul><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ df [-ahikHTm] [目录或文件名]</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</span><br><span class="line">-k ：以 KBytes 的容量显示各文件系统；</span><br><span class="line">-m ：以 MBytes 的容量显示各文件系统；</span><br><span class="line">-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</span><br><span class="line">-H ：以 M=1000K 取代 M=1024K 的进位方式；</span><br><span class="line">-T ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出；</span><br><span class="line">-i ：不用磁盘容量，而以 inode 的数量来显示</span><br><span class="line">范例一：将系统内所有的 filesystem 列出来！</span><br><span class="line">[root@study ~]$ df</span><br><span class="line">Filesystem 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root 10475520 3409408 7066112 33% /</span><br><span class="line">devtmpfs 627700 0 627700 0% /dev</span><br><span class="line">tmpfs 637568 80 637488 1% /dev/shm</span><br><span class="line">tmpfs 637568 24684 612884 4% /run</span><br><span class="line">tmpfs 637568 0 637568 0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-home 5232640 67720 5164920 2% /home</span><br><span class="line">/dev/vda2 1038336 133704 904632 13% /boot</span><br><span class="line"><span class="comment"># 在 Linux 下面如果 df 没有加任何选项，那么默认会将系统内所有的</span></span><br><span class="line"><span class="comment"># （不含特殊内存内的文件系统与 swap） 都以 1 KBytes 的容量来列出来！</span></span><br><span class="line"><span class="comment"># 至于那个 /dev/shm 是与内存有关的挂载，先不要理他！</span></span><br></pre></td></tr></table></figure><ul><li>Filesystem：代表该文件系统是在哪个 partition ，所以列出设备名称；</li><li>1k-blocks：说明下面的数字单位是 1KB 呦！可利用 -h 或 -m 来改变容量；</li><li>Used：顾名思义，就是使用掉的磁盘空间啦！</li><li>Available：也就是剩下的磁盘空间大小；</li><li>Use%：就是磁盘的使用率啦！如果使用率高达 90% 以上时， 最好需要注意一下了，免得容量不足造成系统问题喔！（例如最容易被灌爆的 /var/spool/mail 这个放置邮件的磁盘）</li><li>Mounted on：就是磁盘挂载的目录所在啦！（挂载点啦！）</li></ul><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ du [-ahskm] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。</span><br><span class="line">-h ：以人们较易读的容量格式 （G/M） 显示；</span><br><span class="line">-s ：列出总量而已，而不列出每个各别的目录占用容量；</span><br><span class="line">-S ：不包括子目录下的总计，与 -s 有点差别。</span><br><span class="line">-k ：以 KBytes 列出容量显示；</span><br><span class="line">-m ：以 MBytes 列出容量显示；</span><br></pre></td></tr></table></figure><blockquote><p>与 df 不一样的是，du 这个指令其实会直接到文件系统内去搜寻所有的文件数据</p></blockquote><h3 id="实体链接与符号链接：-ln"><a href="#实体链接与符号链接：-ln" class="headerlink" title="实体链接与符号链接： ln"></a>实体链接与符号链接： ln</h3><h4 id="Hard-Link-（实体链接-硬式链接或实际链接）"><a href="#Hard-Link-（实体链接-硬式链接或实际链接）" class="headerlink" title="Hard Link （实体链接, 硬式链接或实际链接）"></a>Hard Link （实体链接, 硬式链接或实际链接）</h4><ul><li>每个文件都会占用一个 inode ，文件内容由 inode 的记录来指向；</li><li>想要读取该文件，必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ll -i /etc/crontab</span><br><span class="line">34474855 -rw-r--r--. 1 root root 451 Jun 10 2014 /etc/crontab</span><br><span class="line">[root@study ~]$ ln /etc/crontab . &lt;==创建实体链接的指令</span><br><span class="line">[root@study ~]$ ll -i /etc/crontab crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab</span><br></pre></td></tr></table></figure><p>“链接” 从 1 变成 2 ，这个字段的意义为：“有多少个文件名链接到这个 inode 号码”的意思。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/23/QYn8u6JFgCLaNDy.png" alt="实体链接的文件读取示意图"></p><blockquote><p>hard link 的制作中，其实还是可能会改变系统的 block 的，那就是当你新增这笔数据却刚好将目录的 block 填满时，就可能会新加一个 block 来记录文件名关连性，而导致磁盘空间的变化！不过，一般 hard link 所用掉的关连数据量很小，所以通常不会改变 inode 与磁盘空间的大小喔！</p></blockquote><p>一般来说，使用 hard link 设置链接文件时，磁盘的空间与 inode 的数目都不会改变！ 由图中可以知道， hard link 只是在某个目录下的 block 多写入一个关连数据而已，既不会增加 inode 也不会耗用 block 数量哩！</p><p>hard link 是有限制的：</p><ul><li>不能跨 Filesystem；</li><li>不能 link 目录。</li></ul><h4 id="Symbolic-Link-（符号链接，亦即是捷径）"><a href="#Symbolic-Link-（符号链接，亦即是捷径）" class="headerlink" title="Symbolic Link （符号链接，亦即是捷径）"></a>Symbolic Link （符号链接，亦即是捷径）</h4><p>Symbolic link 可就好理解多了，基本上， Symbolic link 就是在创建一个<br>独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名！由于只是利用文件来做为指向的动作， 所以，当来源文件被删除之后，symbolic link 的文件会“开不了”， 会一直说“无法打开某文件！”。实际上就是找不到原始“文件名”而已啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ ll /etc/crontab ./crontab.*</span><br><span class="line">-rw-r--r--. 1 root root 451 Sep 24 10:09 ./crontab.cp</span><br><span class="line">-rw-r--r--. 1 root root 451 Jun 10  2014 ./crontab.cpp</span><br><span class="line">-rw-r--r--. 2 root root 451 Jun 10  2014 ./crontab.hard</span><br><span class="line">lrwxrwxrwx. 1 root root  12 Sep 24 10:08 ./crontab.soft -&gt; /etc/crontab</span><br><span class="line">-rw-r--r--. 2 root root 451 Jun 10  2014 /etc/crontab</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/24/qiLV7JXF24NmExK.png" alt="符号链接的文件读取示意图"></p><blockquote><p>这里还是得特别留意，这个 Symbolic Link 与 Windows 的捷径可以给他划上等号，由Symbolic link 所创建的文件为一个独立的新的文件，所以会占用掉 inode 与 block 喔！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ln [-sf] 来源文件 目标文件</span><br><span class="line">选项与参数：</span><br><span class="line">-s ：如果不加任何参数就进行链接，那就是hard link，至于 -s 就是symbolic link</span><br><span class="line">-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！</span><br></pre></td></tr></table></figure><h2 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h2><ol><li>对磁盘进行分区，以创建可用的 partition ；</li><li>对该 partition 进行格式化 （format），以创建系统可用的 filesystem；</li><li>若想要仔细一点，则可对刚刚创建好的 filesystem 进行检验；</li><li>在 Linux 系统上，需要创建挂载点 （亦即是目录），并将他挂载上来；</li></ol><h3 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h3><h4 id="lsblk-列出系统上的所有磁盘列表"><a href="#lsblk-列出系统上的所有磁盘列表" class="headerlink" title="lsblk 列出系统上的所有磁盘列表"></a>lsblk 列出系统上的所有磁盘列表</h4><p>lsblk 可以看成“ list block device ”的缩写，就是列出所有储存设备的意思！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ lsblk [-dfimpt] [device]</span><br><span class="line">选项与参数：</span><br><span class="line">-d ：仅列出磁盘本身，并不会列出该磁盘的分区数据</span><br><span class="line">-f ：同时列出该磁盘内的文件系统名称</span><br><span class="line">-i ：使用 ASCII 的线段输出，不要使用复杂的编码 （再某些环境下很有用）</span><br><span class="line">-m ：同时输出该设备在 /dev 下面的权限数据 （rwx 的数据）</span><br><span class="line">-p ：列出该设备的完整文件名！而不是仅列出最后的名字而已。</span><br><span class="line">-t ：列出该磁盘设备的详细数据，包括磁盘伫列机制、预读写的数据量大小等</span><br><span class="line"></span><br><span class="line">范例一：列出本系统下的所有磁盘与磁盘内的分区信息</span><br><span class="line">[root@localhost ~]$ lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0  127G  0 disk</span><br><span class="line">├─sda1            8:1    0    2M  0 part</span><br><span class="line">├─sda2            8:2    0    1G  0 part /boot</span><br><span class="line">└─sda3            8:3    0   35G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   30G  0 lvm  /</span><br><span class="line">  ├─centos-swap 253:1    0    4M  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:2    0    5G  0 lvm  /home</span><br><span class="line">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure><ul><li>NAME：就是设备的文件名啰！会省略 /dev 等前导目录</li><li>MAJ:MIN：其实核心认识的设备都是通过这两个代码来熟悉的！分别是主要：次要设备代码</li><li>RM：是否为可卸载设备 （removable device），如光盘、USB 磁盘等等</li><li>SIZE：容量</li><li>RO：是否为只读设备的意思</li><li>TYPE：是磁盘 （disk）、分区 （partition） 还是只读存储器 （rom）等输出</li><li>MOUTPOINT：挂载点</li></ul><h4 id="blkid-列出设备的-UUID-等参数"><a href="#blkid-列出设备的-UUID-等参数" class="headerlink" title="blkid 列出设备的 UUID 等参数"></a>blkid 列出设备的 UUID 等参数</h4><p>什么是 UUID 呢？UUID 是全域单一识别码（universally unique identifier），Linux 会将系统内所有的设备都给予一个独一无二的识别码， 这个识别码就可以拿来作为挂载或者是使用这个设备/文件系统之用了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ blkid</span><br><span class="line">/dev/sda2: UUID=<span class="string">&quot;243cc327-5655-4a87-8178-3f59be083031&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> PARTUUID=<span class="string">&quot;30d4a8e1-88b3-43de-8b76-40aef253a15b&quot;</span></span><br><span class="line">/dev/sda3: UUID=<span class="string">&quot;v7xjPn-WCbG-Wuvw-oXr3-Ju9N-yBEk-fJf1Am&quot;</span> TYPE=<span class="string">&quot;LVM2_member&quot;</span> PARTUUID=<span class="string">&quot;cdfb7a99-8532-48d9-8e2e-662af2e5ce69&quot;</span></span><br><span class="line">/dev/mapper/centos-root: UUID=<span class="string">&quot;c2ada878-3d9f-4dff-a68f-fa237ab94968&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line">/dev/mapper/centos-swap: UUID=<span class="string">&quot;f4fccc29-4a38-4ca1-8f8f-99b99fa4fde1&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span></span><br><span class="line">/dev/mapper/centos-home: UUID=<span class="string">&quot;ae0ce3d3-db6e-4989-b8ff-7b88fd1e88b6&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br></pre></td></tr></table></figure><h4 id="parted-列出磁盘的分区表类型与分区信息"><a href="#parted-列出磁盘的分区表类型与分区信息" class="headerlink" title="parted 列出磁盘的分区表类型与分区信息"></a>parted 列出磁盘的分区表类型与分区信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ parted device_name <span class="built_in">print</span></span><br><span class="line">范例一：列出 /dev/vda 磁盘的相关数据</span><br><span class="line">[root@study ~]$ parted /dev/vda <span class="built_in">print</span></span><br><span class="line">Model: Virtio Block Device （virtblk） <span class="comment"># 磁盘的模块名称（厂商）</span></span><br><span class="line">Disk /dev/vda: 42.9GB <span class="comment"># 磁盘的总容量</span></span><br><span class="line">Sector size （logical/physical）: 512B/512B <span class="comment"># 磁盘的每个逻辑/物理扇区容量</span></span><br><span class="line">Partition Table: gpt <span class="comment"># 分区表的格式 （MBR/GPT）</span></span><br><span class="line">Disk Flags: pmbr_boot</span><br><span class="line">Number Start End Size File system Name Flags <span class="comment"># 下面才是分区数据</span></span><br><span class="line">1 1049kB 3146kB 2097kB bios_grub</span><br><span class="line">2 3146kB 1077MB 1074MB xfs</span><br><span class="line">3 1077MB 33.3GB 32.2GB lvm</span><br></pre></td></tr></table></figure><h3 id="磁盘分区：-gdisk-fdisk"><a href="#磁盘分区：-gdisk-fdisk" class="headerlink" title="磁盘分区： gdisk/fdisk"></a>磁盘分区： gdisk/fdisk</h3><blockquote><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区</p></blockquote><h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ gdisk 设备名称</span><br><span class="line">范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据</span><br><span class="line">[root@study ~]$ gdisk /dev/vda &lt;==仔细看，不要加上数字喔！</span><br><span class="line">GPT fdisk （gdisk） version 0.8.6</span><br><span class="line">Partition table scan:</span><br><span class="line">MBR: protective</span><br><span class="line">BSD: not present</span><br><span class="line">APM: not present</span><br><span class="line">GPT: present</span><br><span class="line">Found valid GPT with protective MBR; using GPT. &lt;==找到了 GPT 的分区表！</span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: &amp;lt;==这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令</span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: ?</span><br><span class="line">b back up GPT data to a file</span><br><span class="line">c change a partition<span class="string">&#x27;s name</span></span><br><span class="line"><span class="string">d delete a partition # 删除一个分区</span></span><br><span class="line"><span class="string">i show detailed information on a partition</span></span><br><span class="line"><span class="string">l list known partition types</span></span><br><span class="line"><span class="string">n add a new partition # 增加一个分区</span></span><br><span class="line"><span class="string">o create a new empty GUID partition table （GPT）</span></span><br><span class="line"><span class="string">p print the partition table # 印出分区表 （常用）</span></span><br><span class="line"><span class="string">q quit without saving changes # 不储存分区就直接离开 gdisk</span></span><br><span class="line"><span class="string">r recovery and transformation options （experts only）</span></span><br><span class="line"><span class="string">s sort partitions</span></span><br><span class="line"><span class="string">t change a partition&#x27;</span>s <span class="built_in">type</span> code</span><br><span class="line">v verify disk</span><br><span class="line">w write table to disk and <span class="built_in">exit</span> <span class="comment"># 储存分区操作后离开 gdisk</span></span><br><span class="line">x extra functionality （experts only）</span><br><span class="line">? <span class="built_in">print</span> this menu</span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）:</span><br></pre></td></tr></table></figure><blockquote><p>你应该要通过 <code>lsblk</code> 或 <code>blkid</code> 先找到磁盘，再用 <code>parted /dev/xxx print</code> 来找出内部的分区表类型，之后才用 <code>gdisk</code> 或 <code>fdisk</code> 来操作系统。</p></blockquote><h4 id="partprobe-更新-Linux-核心的分区表信息"><a href="#partprobe-更新-Linux-核心的分区表信息" class="headerlink" title="partprobe 更新 Linux 核心的分区表信息"></a>partprobe 更新 Linux 核心的分区表信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ partprobe [-s] <span class="comment"># 你可以不要加 -s ！那么屏幕不会出现讯息！</span></span><br><span class="line">[root@study ~]$ partprobe -s <span class="comment"># 不过还是建议加上 -s 比较清晰！</span></span><br></pre></td></tr></table></figure><h3 id="磁盘格式化（创建文件系统）"><a href="#磁盘格式化（创建文件系统）" class="headerlink" title="磁盘格式化（创建文件系统）"></a>磁盘格式化（创建文件系统）</h3><h4 id="XFS-文件系统-mkfs-xfs"><a href="#XFS-文件系统-mkfs-xfs" class="headerlink" title="XFS 文件系统 mkfs.xfs"></a>XFS 文件系统 mkfs.xfs</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \</span><br><span class="line">[-r parms] 设备名称</span><br><span class="line">选项与参数：</span><br><span class="line">关於单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释</span><br><span class="line">比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！</span><br><span class="line">-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！</span><br><span class="line">-d ：后面接的是重要的 data section 的相关参数值，主要的值有：</span><br><span class="line">agcount=数值 ：设置需要几个储存群组的意思（AG），通常与 CPU 有关</span><br><span class="line">agsize=数值 ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可</span><br><span class="line">file ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）</span><br><span class="line">size=数值 ：data section 的容量，亦即你可以不将全部的设备容量用完的意思</span><br><span class="line">su=数值 ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用</span><br><span class="line">sw=数值 ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）</span><br><span class="line">sunit=数值 ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思</span><br><span class="line">swidth=数值 ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置</span><br><span class="line">-f ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！</span><br><span class="line">-i ：与 inode 有较相关的设置，主要的设置值有：</span><br><span class="line">size=数值 ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！</span><br><span class="line">internal=[0&amp;<span class="comment">#124;1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置</span></span><br><span class="line">logdev=device ：<span class="built_in">log</span> 设备为后面接的那个设备上头的意思，需设置 internal=0 才可！</span><br><span class="line">size=数值 ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！</span><br><span class="line">-L ：后面接这个文件系统的标头名称 Label name 的意思！</span><br><span class="line">-r ：指定 realtime section 的相关设置值，常见的有：</span><br><span class="line">extsize=数值 ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，</span><br><span class="line">最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。</span><br></pre></td></tr></table></figure><h4 id="EXT4-文件系统-mkfs-ext4"><a href="#EXT4-文件系统-mkfs-ext4" class="headerlink" title="EXT4 文件系统 mkfs.ext4"></a>EXT4 文件系统 mkfs.ext4</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mkfs.ext4 [-b size] [-L label] 设备名称</span><br><span class="line">选项与参数：</span><br><span class="line">-b ：设置 block 的大小，有 1K, 2K, 4K 的容量，</span><br><span class="line">-L ：后面接这个设备的标头名称。</span><br></pre></td></tr></table></figure><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><h4 id="xfs-repair-处理-XFS-文件系统"><a href="#xfs-repair-处理-XFS-文件系统" class="headerlink" title="xfs_repair 处理 XFS 文件系统"></a>xfs_repair 处理 XFS 文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfs_repair [-fnd] 设备名称</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：后面的设备其实是个文件而不是实体设备</span><br><span class="line">-n ：单纯检查并不修改文件系统的任何数据 （检查而已）</span><br><span class="line">-d ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用</span><br></pre></td></tr></table></figure><h4 id="fsck-ext4-处理-EXT4-文件系统"><a href="#fsck-ext4-处理-EXT4-文件系统" class="headerlink" title="fsck.ext4 处理 EXT4 文件系统"></a>fsck.ext4 处理 EXT4 文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ fsck.ext4 [-pf] [-b superblock] 设备名称</span><br><span class="line">选项与参数：</span><br><span class="line">-p ：当文件系统在修复时，若有需要回复 y 的动作时，自动回复 y 来继续进行修复动作。</span><br><span class="line">-f ：强制检查！一般来说，如果 fsck 没有发现任何 unclean 的旗标，不会主动进入</span><br><span class="line">细部检查的，如果您想要强制 fsck 进入细部检查，就得加上 -f 旗标啰！</span><br><span class="line">-D ：针对文件系统下的目录进行最优化配置。</span><br><span class="line">-b ：后面接 superblock 的位置！一般来说这个选项用不到。但是如果你的 superblock 因故损毁时，</span><br><span class="line">通过这个参数即可利用文件系统内备份的 superblock 来尝试救援。一般来说，superblock 备份在：</span><br><span class="line">1K block 放在 8193, 2K block 放在 16384, 4K block 放在 32768</span><br></pre></td></tr></table></figure><h3 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h3><ul><li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中；</li><li>单一目录不应该重复挂载多个文件系统；</li><li>要作为挂载点的目录，理论上应该都是空目录才是。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mount -a</span><br><span class="line">[root@study ~]$ mount [-l]</span><br><span class="line">[root@study ~]$ mount [-t 文件系统] LABEL=<span class="string">&#x27;&#x27;</span> 挂载点</span><br><span class="line">[root@study ~]$ mount [-t 文件系统] UUID=<span class="string">&#x27;&#x27;</span> 挂载点 <span class="comment"># 建议用这种方式</span></span><br><span class="line">[root@study ~]$ mount [-t 文件系统] 设备文件名 挂载点</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：依照配置文件 [/etc/fstab](../Text/index.html<span class="comment">#fstab) 的数据将所有未挂载的磁盘都挂载上来</span></span><br><span class="line">-l ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称！</span><br><span class="line">-t ：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有：xfs, ext3, ext4,</span><br><span class="line">reiserfs, vfat, iso9660（光盘格式）, nfs, cifs, smbfs （后三种为网络文件系统类型）</span><br><span class="line">-n ：在默认的情况下，系统会将实际挂载的情况实时写入 /etc/mtab 中，以利其他程序的运行。</span><br><span class="line">但在某些情况下（例如单人维护模式）为了避免问题会刻意不写入。此时就得要使用 -n 选项。</span><br><span class="line">-o ：后面可以接一些挂载时额外加上的参数！比方说帐号、密码、读写权限等：</span><br><span class="line">async, sync: 此文件系统是否使用同步写入 （sync） 或非同步 （async） 的</span><br><span class="line">内存机制，请参考[文件系统运行方式](../Text/index.html<span class="comment">#harddisk-filerun)。默认为 async。</span></span><br><span class="line">atime,noatime: 是否修订文件的读取时间（atime）。为了性能，某些时刻可使用 noatime</span><br><span class="line">ro, rw: 挂载文件系统成为只读（ro） 或可读写（rw）</span><br><span class="line">auto, noauto: 允许此 filesystem 被以 mount -a 自动挂载（auto）</span><br><span class="line">dev, nodev: 是否允许此 filesystem 上，可创建设备文件？ dev 为可允许</span><br><span class="line">suid, nosuid: 是否允许此 filesystem 含有 suid/sgid 的文件格式？</span><br><span class="line"><span class="built_in">exec</span>, noexec: 是否允许此 filesystem 上拥有可执行 binary 文件？</span><br><span class="line">user, nouser: 是否允许此 filesystem 让任何使用者执行 mount ？一般来说，</span><br><span class="line">mount 仅有 root 可以进行，但下达 user 参数，则可让</span><br><span class="line">一般 user 也能够对此 partition 进行 mount 。</span><br><span class="line">defaults: 默认值为：rw, suid, dev, <span class="built_in">exec</span>, auto, nouser, and async</span><br><span class="line">remount: 重新挂载，这在系统出错，或重新更新参数时，很有用！</span><br></pre></td></tr></table></figure><h4 id="重新挂载根目录与挂载不特定目录"><a href="#重新挂载根目录与挂载不特定目录" class="headerlink" title="重新挂载根目录与挂载不特定目录"></a>重新挂载根目录与挂载不特定目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">范例：将 / 重新挂载，并加入参数为 rw 与 auto</span><br><span class="line">[root@study ~]$ mount -o remount,rw,auto /</span><br></pre></td></tr></table></figure><blockquote><p>重点是那个“ -o remount,xx ”的选项与参数！请注意，要重新挂载 （remount） 时， 这是个非常重要的机制！尤其是当你进入单人维护模式时，你的根目录常会被系统挂载为只读，这个时候这个指令就太重要了！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范例：将 /var 这个目录暂时挂载到 /data/var 下面：</span><br><span class="line">[root@study ~]$ mkdir /data/var</span><br><span class="line">[root@study ~]$ mount --<span class="built_in">bind</span> /var /data/var</span><br><span class="line">[root@study ~]$ ls -lid /var /data/var</span><br><span class="line">16777346 drwxr-xr-x. 22 root root 4096 Jun 15 23:43 /data/var</span><br><span class="line">16777346 drwxr-xr-x. 22 root root 4096 Jun 15 23:43 /var</span><br><span class="line"><span class="comment"># 内容完全一模一样啊！因为挂载目录的缘故！</span></span><br><span class="line">[root@study ~]$ mount &amp;<span class="comment">#124; grep var</span></span><br><span class="line">/dev/mapper/centos-root on /data/var <span class="built_in">type</span> xfs （rw,relatime,seclabel,attr2,inode64,noquota）</span><br></pre></td></tr></table></figure><p>看起来，其实两者链接到同一个 inode 嘛！ ^_^ 没错啦！通过这个 mount –bind 的功能， 您<br>可以将某个目录挂载到其他目录去喔！而并不是整块 filesystem 的啦！所以从此进入<br>/data/var 就是进入 /var 的意思喔！</p><h4 id="umount-（将设备文件卸载）"><a href="#umount-（将设备文件卸载）" class="headerlink" title="umount （将设备文件卸载）"></a>umount （将设备文件卸载）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ umount [-fn] 设备文件名或挂载点</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：强制卸载！可用在类似网络文件系统 （NFS） 无法读取到的情况下；</span><br><span class="line">-l ：立刻卸载文件系统，比 -f 还强！</span><br><span class="line">-n ：不更新 /etc/mtab 情况下卸载。</span><br></pre></td></tr></table></figure><h3 id="磁盘-文件系统参数修订"><a href="#磁盘-文件系统参数修订" class="headerlink" title="磁盘/文件系统参数修订"></a>磁盘/文件系统参数修订</h3><h4 id="mknod"><a href="#mknod" class="headerlink" title="mknod"></a>mknod</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ ll /dev/sda*</span><br><span class="line">brw-rw----. 1 root disk 8, 0 Sep 24 16:36 /dev/sda</span><br><span class="line">brw-rw----. 1 root disk 8, 1 Sep 17 14:33 /dev/sda1</span><br><span class="line">brw-rw----. 1 root disk 8, 2 Sep 17 14:33 /dev/sda2</span><br><span class="line">brw-rw----. 1 root disk 8, 3 Sep 17 14:33 /dev/sda3</span><br></pre></td></tr></table></figure><p>上表当中 252 为主要设备代码 （Major） 而 0~5 则为次要设备代码 （Minor）。 我们的Linux 核心认识的设备数据就是通过这两个数值来决定的！举例来说，常见的磁盘文件名<code>/dev/sda</code> 与 <code>/dev/loop0</code> 设备代码如下所示：</p><table><thead><tr><th>磁盘文件名</th><th>Major</th><th>Minor</th></tr></thead><tbody><tr><td>/dev/sda</td><td>8</td><td>0-15</td></tr><tr><td>/dev/sdb</td><td>8</td><td>16-31</td></tr><tr><td>/dev/loop0</td><td>7</td><td>0</td></tr><tr><td>/dev/loop1</td><td>7</td><td>1</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mknod 设备文件名 [bcp] [Major] [Minor]</span><br><span class="line">选项与参数：</span><br><span class="line">设备种类：</span><br><span class="line">b ：设置设备名称成为一个周边储存设备文件，例如磁盘等；</span><br><span class="line">c ：设置设备名称成为一个周边输入设备文件，例如鼠标/键盘等；</span><br><span class="line">p ：设置设备名称成为一个 FIFO 文件；</span><br><span class="line">Major ：主要设备代码；</span><br><span class="line">Minor ：次要设备代码；</span><br></pre></td></tr></table></figure><h4 id="xfs-admin-修改-XFS-文件系统的-UUID-与-Label-name"><a href="#xfs-admin-修改-XFS-文件系统的-UUID-与-Label-name" class="headerlink" title="xfs_admin 修改 XFS 文件系统的 UUID 与 Label name"></a>xfs_admin 修改 XFS 文件系统的 UUID 与 Label name</h4><p>如果你当初格式化的时候忘记加上标头名称，后来想要再次加入时，不需要重复格式化！直接使用这个 xfs_admin 即可。 这个指令直接拿来处理 LABEL name 以及 UUID 即可啰！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ xfs_admin [-lu] [-L label] [-U uuid] 设备文件名</span><br><span class="line">选项与参数：</span><br><span class="line">-l ：列出这个设备的 label name</span><br><span class="line">-u ：列出这个设备的 UUID</span><br><span class="line">-L ：设置这个设备的 Label name</span><br><span class="line">-U ：设置这个设备的 UUID </span><br></pre></td></tr></table></figure><h4 id="tune2fs-修改-ext4-的-label-name-与-UUID"><a href="#tune2fs-修改-ext4-的-label-name-与-UUID" class="headerlink" title="tune2fs 修改 ext4 的 label name 与 UUID"></a>tune2fs 修改 ext4 的 label name 与 UUID</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ tune2fs [-l] [-L Label] [-U uuid] 设备文件名</span><br><span class="line">选项与参数：</span><br><span class="line">-l ：类似 dumpe2fs -h 的功能～将 superblock 内的数据读出来～</span><br><span class="line">-L ：修改 LABEL name</span><br><span class="line">-U ：修改 UUID</span><br></pre></td></tr></table></figure><h2 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h2><h3 id="开机挂载-etc-fstab-及-etc-mtab"><a href="#开机挂载-etc-fstab-及-etc-mtab" class="headerlink" title="开机挂载 /etc/fstab 及 /etc/mtab"></a>开机挂载 /etc/fstab 及 /etc/mtab</h3><p>系统挂载的一些限制：</p><ul><li>根目录 / 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来。</li><li>其它 mount point 必须为已创建的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则 （FHS）</li><li>所有 mount point 在同一时间之内﹐只能挂载一次。</li><li>所有 partition 在同一时间之内﹐只能挂载一次。</li><li>如若进行卸载﹐您必须先将工作目录移到 mount point（及其子目录） 之外。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cat /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Wed Sep  9 06:03:58 2020</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">/dev/mapper/centos-root /                       xfs     defaults        0 0</span><br><span class="line">UUID=243cc327-5655-4a87-8178-3f59be083031 /boot                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-home /home                   xfs     defaults        0 0</span><br><span class="line">/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure><blockquote><p>[设备/UUID等] [挂载点] [文件系统] [文件系统参数] [dump] [fsck]</p></blockquote><table><thead><tr><th>文件系统参数</th><th>内容意义</th></tr></thead><tbody><tr><td>async/sync</br>非同步/同步</td><td>设置磁盘是否以非同步方式运行！默认为 async（性能较佳）</td></tr><tr><td>auto/noauto</br>自动/非自动</td><td>当下达 mount -a 时，此文件系统是否会被主动测试挂载。默认为 auto。</td></tr><tr><td>rw/ro 可读</br>写/只读</td><td>让该分区以可读写或者是只读的型态挂载上来，如果你想要分享的数据是不给使用者随意变更的， 这里也能够设置为只读。则不论在此文件系统的文件是否设置 w 权限，都无法写入喔！</td></tr><tr><td>exec/noexec</br>可执行/不可执行</td><td>限制在此文件系统内是否可以进行“执行”的工作？如果是纯粹用来储存数据的目录， 那么可以设置为 noexec 会比较安全。不过，这个参数也不能随便使用，因为你不知道该目录下是否默认会有可执行文件。举例来说，如果你将 noexec 设置在 /var ，当某些软件将一些可执行文件放置于 /var 下时，那就会产生很大的问题喔！ 因此，建议这个 noexec 最多仅设置于你自订或分享的一般数据目录。</td></tr><tr><td>user/nouser</br>允许/不允许使用者挂载</td><td>是否允许使用者使用 mount指令来挂载呢？一般而言，我们当然不希望一般身份的 user 能使用 mount 啰，因为太不安全了，因此这里应该要设置为 nouser 啰！</td></tr><tr><td>suid/nosuid</br>具有/不具有suid 权限</td><td>该文件系统是否允许 SUID 的存在？如果不是可执行文件放置目录，也可以设置为 nosuid 来取消这个功能！</td></tr><tr><td>defaults</td><td>同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。 基本上，默认情况使用 defaults 设置即可！</td></tr></tbody></table><h3 id="特殊设备-loop-挂载-（镜像文件不烧录就挂载使用）"><a href="#特殊设备-loop-挂载-（镜像文件不烧录就挂载使用）" class="headerlink" title="特殊设备 loop 挂载 （镜像文件不烧录就挂载使用）"></a>特殊设备 loop 挂载 （镜像文件不烧录就挂载使用）</h3><h4 id="挂载光盘-DVD镜像文件"><a href="#挂载光盘-DVD镜像文件" class="headerlink" title="挂载光盘/DVD镜像文件"></a>挂载光盘/DVD镜像文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ll -h /tmp/CentOS-7.0-1406-x86_64-DVD.iso</span><br><span class="line">-rw-r--r--. 1 root root 3.9G Jul 7 2014 /tmp/CentOS-7.0-1406-x86_64-DVD.iso</span><br><span class="line"><span class="comment"># 看到上面的结果吧！这个文件就是镜像文件，文件非常的大吧！</span></span><br><span class="line">[root@study ~]$ mkdir /data/centos_dvd</span><br><span class="line">[root@study ~]$ mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd</span><br><span class="line">[root@study ~]$ df /data/centos_dvd</span><br><span class="line">Filesystem 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/loop0 4050860 4050860 0 100% /data/centos_dvd</span><br><span class="line"><span class="comment"># 就是这个项目！ .iso 镜像文件内的所有数据可以在 /data/centos_dvd 看到！</span></span><br><span class="line">[root@study ~]$ ll /data/centos_dvd</span><br><span class="line">total 607</span><br><span class="line">-rw-r--r--. 1 500 502 14 Jul 5 2014 CentOS_BuildTag &lt;==瞧！就是DVD的内容啊！</span><br><span class="line">drwxr-xr-x. 3 500 502 2048 Jul 4 2014 EFI</span><br><span class="line">-rw-r--r--. 1 500 502 611 Jul 5 2014 EULA</span><br><span class="line">-rw-r--r--. 1 500 502 18009 Jul 5 2014 GPL</span><br><span class="line">drwxr-xr-x. 3 500 502 2048 Jul 4 2014 images</span><br><span class="line">.....（下面省略）.....</span><br><span class="line">[root@study ~]$ umount /data/centos_dvd/</span><br><span class="line"><span class="comment"># 测试完成！记得将数据给他卸载！同时这个镜像文件也被鸟哥删除了...测试机容量不够大！</span></span><br></pre></td></tr></table></figure><h4 id="创建大文件以制作-loop-设备文件！"><a href="#创建大文件以制作-loop-设备文件！" class="headerlink" title="创建大文件以制作 loop 设备文件！"></a>创建大文件以制作 loop 设备文件！</h4><p>如果当初在分区时， 你只有分区出一个根目录，假设你已经没有多余的容量可以进行额外的分区的！偏偏根目录的容量还很大！ 此时你就能够制作出一个大文件，然后将这个文件挂载！如此一来感觉上你就多了一个分区啰！用途非常的广泛啦！</p><h4 id="创建大型文件"><a href="#创建大型文件" class="headerlink" title="创建大型文件"></a>创建大型文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ dd <span class="keyword">if</span>=/dev/zero of=/srv/loopdev bs=1M count=512</span><br><span class="line">512+0 records <span class="keyword">in</span> &amp;lt;==读入 512 笔数据</span><br><span class="line">512+0 records out &amp;lt;==输出 512 笔数据</span><br><span class="line">536870912 Bytes （537 MB） copied, 12.3484 seconds, 43.5 MB/s</span><br><span class="line"><span class="comment"># 这个指令的简单意义如下：</span></span><br><span class="line"><span class="comment"># if 是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的设备！</span></span><br><span class="line"><span class="comment"># of 是 output file ，将一堆零写入到后面接的文件中。</span></span><br><span class="line"><span class="comment"># bs 是每个 block 大小，就像文件系统那样的 block 意义；</span></span><br><span class="line"><span class="comment"># count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了！</span></span><br><span class="line">[root@study ~]$ ll -h /srv/loopdev</span><br><span class="line">-rw-r--r--. 1 root root 512M Jun 25 19:46 /srv/loopdev</span><br></pre></td></tr></table></figure><h4 id="大型文件的格式化"><a href="#大型文件的格式化" class="headerlink" title="大型文件的格式化"></a>大型文件的格式化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mkfs.xfs -f /srv/loopdev</span><br><span class="line">[root@study ~]$ blkid /srv/loopdev</span><br><span class="line">/srv/loopdev: UUID=<span class="string">&quot;7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br></pre></td></tr></table></figure><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>利用 mount 的特殊参数，那个 -o loop 的参数来处理！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mount -o loop UUID=<span class="string">&quot;7dd97bd2-4446-48fd-9d23-a8b03ffdd5ee&quot;</span> /mnt</span><br><span class="line">[root@study ~]$ df /mnt</span><br><span class="line">Filesystem 1K-blocks Used Available Use% Mounted on</span><br><span class="line">/dev/loop0 520876 26372 494504 6% /mnt</span><br></pre></td></tr></table></figure><blockquote><p>CentOS 7.x 越来越聪明了，现在你不需要下达 -o loop 这个选项与参数，它同样可以被系统挂上来！ 连直接输入 blkid 都会列出这个文件内部的文件系统耶！相当有趣！不过，为了考虑向下兼容性，鸟哥还是建议你加上 loop 比较妥当喔！ 现在，请将这个文件系统永远的自动挂载起来吧！</p></blockquote><h2 id="内存交换空间（swap）之创建"><a href="#内存交换空间（swap）之创建" class="headerlink" title="内存交换空间（swap）之创建"></a>内存交换空间（swap）之创建</h2><h3 id="使用实体分区创建swap"><a href="#使用实体分区创建swap" class="headerlink" title="使用实体分区创建swap"></a>使用实体分区创建swap</h3><p>创建 swap 分区的步骤：</p><ol><li>分区：先使用 gdisk 在你的磁盘中分区出一个分区给系统作为 swap 。由于 Linux 的<br>gdisk 默认会将分区的 ID 设置为 Linux 的文件系统，所以你可能还得要设置一下 system ID 就是了。</li><li>格式化：利用创建 swap 格式的“mkswap 设备文件名”就能够格式化该分区成为 swap 格式</li><li>使用：最后将该 swap 设备启动，方法为：“swapon 设备文件名”。</li><li>观察：最终通过 free 与 swapon -s 这个指令来观察一下内存的用量吧！</li></ol><h2 id="文件系统的特殊观察与操作"><a href="#文件系统的特殊观察与操作" class="headerlink" title="文件系统的特殊观察与操作"></a>文件系统的特殊观察与操作</h2><h3 id="磁盘空间之浪费问题"><a href="#磁盘空间之浪费问题" class="headerlink" title="磁盘空间之浪费问题"></a>磁盘空间之浪费问题</h3><blockquote><p>整个文件系统中包括 superblock, inode table 与其他中介数据等其实都会浪费磁盘容量喔！</p></blockquote><p><code>ls -l</code> 第一行的 total 就是该目录下所有数据所使用的 *<em>实际block数量 * block大小的值*</em>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ll -sh</span><br><span class="line">total 12K</span><br><span class="line">4.0K -rw-------. 1 root root 1.8K May 4 17:57 anaconda-ks.cfg</span><br><span class="line">4.0K -rw-r--r--. 2 root root 451 Jun 10 2014 crontab</span><br><span class="line">0 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 crontab2 -&amp;gt; /etc/crontab</span><br><span class="line">4.0K -rw-r--r--. 1 root root 1.9K May 4 18:01 initial-setup-ks.cfg</span><br><span class="line">0 -rw-r--r--. 1 root root 0 Jun 16 01:11 test1</span><br><span class="line">0 drwxr-xr-x. 2 root root 6 Jun 16 01:11 test2</span><br><span class="line">0 -rw-rw-r--. 1 root root 0 Jun 16 01:12 test3</span><br><span class="line">0 drwxrwxr-x. 2 root root 6 Jun 16 01:12 test4</span><br></pre></td></tr></table></figure><h3 id="利用-GNU-的-parted-进行分区行为（Optional）"><a href="#利用-GNU-的-parted-进行分区行为（Optional）" class="headerlink" title="利用 GNU 的 parted 进行分区行为（Optional）"></a>利用 GNU 的 parted 进行分区行为（Optional）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># parted [设备] [指令 [参数]]</span></span><br><span class="line">选项与参数：</span><br><span class="line">指令功能：</span><br><span class="line">新增分区：mkpart [primary&amp;<span class="comment">#124;logical&amp;#124;extended] [ext4&amp;#124;vfat&amp;#124;xfs] 开始 结束</span></span><br><span class="line">显示分区：<span class="built_in">print</span></span><br><span class="line">删除分区：rm [partition]</span><br></pre></td></tr></table></figure><p>可以使用<code>man parted</code>，或者是<code>parted /dev/vda help mkpart</code>去查询更详细的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘 </tag>
            
            <tag> 文件系统管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件与目录管理</title>
      <link href="/2020/09/11/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <url>/2020/09/11/Linux%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="目录与路径"><a href="#目录与路径" class="headerlink" title="目录与路径"></a>目录与路径</h2><h3 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h3><ul><li>绝对路径：路径的写法“一定由根目录 / 写起”</li><li>相对路径：路径的写法“不是由 / 写起”</li></ul><h3 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h3><ul><li><code>.</code> 代表此层目录</li><li><code>..</code> 代表上一层目录</li><li><code>-</code> 代表前一个工作目录</li><li><code>~</code> 代表“目前使用者身份”所在的主文件夹</li><li><code>~account</code> 代表 account 这个使用者的主文件夹（account是个帐号名称）</li></ul><p>处理目录的指令</p><ul><li>cd：变换目录  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">cd</span> [相对路径或绝对路径]</span><br><span class="line"><span class="comment"># 最重要的就是目录的绝对路径与相对路径，还有一些特殊目录的符号啰！</span></span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> ~dmtsai</span><br><span class="line"><span class="comment"># 代表去到 dmtsai 这个使用者的主文件夹，亦即 /home/dmtsai</span></span><br><span class="line">[root@study dmtsai]$ <span class="built_in">cd</span> ~</span><br><span class="line"><span class="comment"># 表示回到自己的主文件夹，亦即是 /root 这个目录</span></span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span></span><br><span class="line"><span class="comment"># 没有加上任何路径，也还是代表回到自己主文件夹的意思喔！</span></span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment"># 表示去到目前的上层目录，亦即是 /root 的上层目录的意思；</span></span><br><span class="line">[root@study /]$ <span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 表示回到刚刚的那个目录，也就是 /root 啰～</span></span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> /var/spool/mail</span><br><span class="line"><span class="comment"># 这个就是绝对路径的写法！直接指定要去的完整路径名称！</span></span><br><span class="line">[root@study mail]$ <span class="built_in">cd</span> ../postfix</span><br><span class="line"><span class="comment"># 这个是相对路径的写法，我们由/var/spool/mail 去到/var/spool/postfix 就这样写！</span></span><br></pre></td></tr></table></figure></li><li>pwd：显示目前的目录  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">pwd</span> [-P]</span><br><span class="line">选项与参数：</span><br><span class="line">-P ：显示出确实的路径，而非使用链接 （link） 路径。</span><br><span class="line">范例：单纯显示出目前的工作目录：</span><br><span class="line">[root@study ~]$ <span class="built_in">pwd</span></span><br><span class="line">/root &lt;== 显示出目录啦～</span><br><span class="line">范例：显示出实际的工作目录，而非链接文件本身的目录名而已</span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> /var/mail &lt;==注意，/var/mail是一个链接文件</span><br><span class="line">[root@study mail]$ <span class="built_in">pwd</span></span><br><span class="line">/var/mail &lt;==列出目前的工作目录</span><br><span class="line">[root@study mail]$ <span class="built_in">pwd</span> -P</span><br><span class="line">/var/spool/mail &lt;==怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@study mail]$ ls -ld /var/mail</span><br><span class="line">lrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&amp;gt; spool/mail</span><br><span class="line"><span class="comment"># 看到这里应该知道为啥了吧？因为 /var/mail 是链接文件，链接到 /var/spool/mail</span></span><br><span class="line"><span class="comment"># 所以，加上 pwd -P 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径啊！</span></span><br></pre></td></tr></table></figure></li><li>mkdir：创建一个新的目录  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mkdir [-mp] 目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-m ：设置文件的权限喔！直接设置，不需要看默认权限 （<span class="built_in">umask</span>） 的脸色～</span><br><span class="line">-p ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！</span><br><span class="line">范例：请到/tmp下面尝试创建数个新目录看看：</span><br><span class="line">[root@study ~]$ <span class="built_in">cd</span> /tmp</span><br><span class="line">[root@study tmp]$ mkdir <span class="built_in">test</span> &lt;==创建一名为 <span class="built_in">test</span> 的新目录</span><br><span class="line">[root@study tmp]$ mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory ‘test1/test2/test3/test4’: No such   file or directory</span><br><span class="line"><span class="comment"># 话说，系统告诉我们，没可能创建这个目录啊！就是没有目录才要创建的！见鬼嘛？</span></span><br><span class="line">[root@study tmp]$ mkdir -p test1/test2/test3/test4</span><br><span class="line"><span class="comment"># 原来是要建 test4 上层没先建 test3 之故！加了这个 -p 的选项，可以自行  帮你创建多层目录！</span></span><br><span class="line">范例：创建权限为rwx--x--x的目录</span><br><span class="line">[root@study tmp]$ mkdir -m 711 test2</span><br><span class="line">[root@study tmp]$ ls -ld <span class="built_in">test</span>*</span><br><span class="line">drwxr-xr-x. 2 root root 6 Jun 4 19:03 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1</span><br><span class="line">drwx--x--x. 2 root root 6 Jun 4 19:05 test2</span><br><span class="line"><span class="comment"># 仔细看上面的权限部分，如果没有加上 -m 来强制设置属性，系统会使用默认属性。</span></span><br><span class="line"><span class="comment"># 那么你的默认属性为何？这要通过下面介绍的 [umask](../Text/index.   html#umask) 才能了解喔！ ^_^</span></span><br></pre></td></tr></table></figure></li><li>rmdir：删除一个空的目录  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># rmdir [-p] 目录名称</span></span><br><span class="line">选项与参数：</span><br><span class="line">-p ：连同“上层”“空的”目录也一起删除</span><br><span class="line">范例：将于mkdir范例中创建的目录（/tmp下面）删除掉！</span><br><span class="line">[root@study tmp]<span class="comment"># ls -ld test* &lt;==看看有多少目录存在？</span></span><br><span class="line">drwxr-xr-x. 2 root root 6 Jun 4 19:03 <span class="built_in">test</span></span><br><span class="line">drwxr-xr-x. 3 root root 18 Jun 4 19:04 test1</span><br><span class="line">drwx--x--x. 2 root root 6 Jun 4 19:05 test2</span><br><span class="line">[root@study tmp]<span class="comment"># rmdir test &lt;==可直接删除掉，没问题</span></span><br><span class="line">[root@study tmp]<span class="comment"># rmdir test1 &lt;==因为尚有内容，所以无法删除！</span></span><br><span class="line">rmdir: failed to remove ‘test1’: Directory not empty</span><br><span class="line">[root@study tmp]<span class="comment"># rmdir -p test1/test2/test3/test4</span></span><br><span class="line">[root@study tmp]<span class="comment"># ls -ld test* &lt;==您看看，下面的输出中test与 test1不见了！</span></span><br><span class="line">drwx--x--x. 2 root root 6 Jun 4 19:05 test2</span><br><span class="line"><span class="comment"># 瞧！利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除   ～</span></span><br><span class="line"><span class="comment"># 不过要注意的是，这个 rmdir 仅能“删除空的目录”喔！</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="可执行文件路径的变量：-PATH"><a href="#可执行文件路径的变量：-PATH" class="headerlink" title="可执行文件路径的变量： $PATH"></a>可执行文件路径的变量： $PATH</h3><ul><li>不同身份使用者默认的PATH不同，默认能够随意执行的指令也不同（如root与blackgane）；</li><li>PATH是可以修改的；</li><li>使用绝对路径或相对路径直接指定某个指令的文件名来执行，会比搜寻PATH来的正确；</li><li>指令应该要放置到正确的目录下，执行才会比较方便；</li><li>本目录（.）最好不要放到PATH当中。</li></ul><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="文件与目录的检视：-ls"><a href="#文件与目录的检视：-ls" class="headerlink" title="文件与目录的检视： ls"></a>文件与目录的检视： ls</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ ls [-aAdfFhilnrRSt] 文件名或目录名称..</span><br><span class="line">[root@study ~]$ ls [--color=&#123;never,auto,always&#125;] 文件名或目录名称..</span><br><span class="line">[root@study ~]$ ls [--full-time] 文件名或目录名称..</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</span><br><span class="line">-A ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</span><br><span class="line">-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）</span><br><span class="line">-f ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</span><br><span class="line">-F ：根据文件、目录等信息，给予附加数据结构，例如：</span><br><span class="line">*:代表可可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；</span><br><span class="line">-h ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</span><br><span class="line">-i ：列出 inode 号码，inode 的意义下一章将会介绍；</span><br><span class="line">-l ：长数据串行出，包含文件的属性与权限等等数据；（常用）</span><br><span class="line">-n ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</span><br><span class="line">-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</span><br><span class="line">-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</span><br><span class="line">-S ：以文件大小大小排序，而不是用文件名排序；</span><br><span class="line">-t ：依时间排序，而不是用文件名。</span><br><span class="line">--color=never ：不要依据文件特性给予颜色显示；</span><br><span class="line">--color=always ：显示颜色</span><br><span class="line">--color=auto ：让系统自行依据设置来判断是否给予颜色</span><br><span class="line">--full-time ：以完整时间模式 （包含年、月、日、时、分） 输出</span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）而非内容变更时间 （modification time）</span><br></pre></td></tr></table></figure><h3 id="复制、删除与移动：-cp-rm-mv"><a href="#复制、删除与移动：-cp-rm-mv" class="headerlink" title="复制、删除与移动： cp, rm, mv"></a>复制、删除与移动： cp, rm, mv</h3><h4 id="cp-（复制文件或目录）"><a href="#cp-（复制文件或目录）" class="headerlink" title="cp （复制文件或目录）"></a>cp （复制文件或目录）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ cp [-adfilprsu] 来源文件（<span class="built_in">source</span>） 目标文件（destination）</span><br><span class="line">[root@study ~]$ cp [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）</span><br><span class="line">-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</span><br><span class="line">-f ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</span><br><span class="line">-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</span><br><span class="line">-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</span><br><span class="line">-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</span><br><span class="line">-r ：递回持续复制，用于目录的复制行为；（常用）</span><br><span class="line">-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</span><br><span class="line">-u ：destination 比 <span class="built_in">source</span> 旧才更新 destination，或 destination 不存在的情况下才复制。</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</span><br><span class="line">最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</span><br></pre></td></tr></table></figure><p>在复制时，你必须要清楚的了解到：</p><ul><li>是否需要完整的保留来源文件的信息？ </li><li>来源文件是否为链接文件 （symbolic link file）？</li><li>来源文件是否为特殊的文件，例如 FIFO, socket 等？</li><li>来源文件是否为目录？</li></ul><h4 id="rm-（移除文件或目录）"><a href="#rm-（移除文件或目录）" class="headerlink" title="rm （移除文件或目录）"></a>rm （移除文件或目录）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ rm [-fir] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</span><br><span class="line">-i ：互动模式，在删除前会询问使用者是否动作</span><br><span class="line">-r ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</span><br></pre></td></tr></table></figure><h4 id="mv-（移动文件与目录，或更名）"><a href="#mv-（移动文件与目录，或更名）" class="headerlink" title="mv （移动文件与目录，或更名）"></a>mv （移动文件与目录，或更名）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ mv [-fiu] <span class="built_in">source</span> destination</span><br><span class="line">[root@study ~]$ mv [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span><br><span class="line">-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</span><br><span class="line">-u ：若目标文件已经存在，且 <span class="built_in">source</span> 比较新，才会更新 （update）</span><br></pre></td></tr></table></figure><h3 id="取得路径的文件名称与目录名称"><a href="#取得路径的文件名称与目录名称" class="headerlink" title="取得路径的文件名称与目录名称"></a>取得路径的文件名称与目录名称</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ basename /etc/sysconfig/network</span><br><span class="line">network  很简单！就取得最后的文件名～</span><br><span class="line">[root@study ~]$ dirname /etc/sysconfig/network</span><br><span class="line">/etc/sysconfig  取得的变成目录名了！</span><br></pre></td></tr></table></figure><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl 显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li><li>od 以二进制的方式读取文件内容！</li></ul><h3 id="直接检视文件内容"><a href="#直接检视文件内容" class="headerlink" title="直接检视文件内容"></a>直接检视文件内容</h3><h4 id="cat-（concatenate）"><a href="#cat-（concatenate）" class="headerlink" title="cat （concatenate）"></a>cat （concatenate）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ cat [-AbEnTv]</span><br><span class="line">选项与参数：</span><br><span class="line">-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</span><br><span class="line">-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</span><br><span class="line">-E ：将结尾的断行字符 $ 显示出来；</span><br><span class="line">-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</span><br><span class="line">-T ：将 [tab] 按键以 ^I 显示出来；</span><br><span class="line">-v ：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure><h4 id="tac-（反向列示）"><a href="#tac-（反向列示）" class="headerlink" title="tac （反向列示）"></a>tac （反向列示）</h4><p>cat的相反用法</p><h4 id="nl-（添加行号打印）"><a href="#nl-（添加行号打印）" class="headerlink" title="nl （添加行号打印）"></a>nl （添加行号打印）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ nl [-bnw] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-b ：指定行号指定的方式，主要有两种：</span><br><span class="line">-b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）；</span><br><span class="line">-b t ：如果有空行，空的那一行不要列出行号（默认值）；</span><br><span class="line">-n ：列出行号表示的方法，主要有三种：</span><br><span class="line">-n ln ：行号在屏幕的最左方显示；</span><br><span class="line">-n rn ：行号在自己字段的最右方显示，且不加 0 ；</span><br><span class="line">-n rz ：行号在自己字段的最右方显示，且加 0 ；</span><br><span class="line">-w ：行号字段的占用的字符数。</span><br></pre></td></tr></table></figure><h3 id="可翻页检视"><a href="#可翻页检视" class="headerlink" title="可翻页检视"></a>可翻页检视</h3><h4 id="more-（一页一页翻动）"><a href="#more-（一页一页翻动）" class="headerlink" title="more （一页一页翻动）"></a>more （一页一页翻动）</h4><ul><li>空白键 （space）：代表向下翻一页；</li><li>Enter ：代表向下翻“一行”；</li><li>/字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li><li>:f ：立刻显示出文件名以及目前显示的行数；</li><li>q ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h4 id="less-（一页一页翻动）"><a href="#less-（一页一页翻动）" class="headerlink" title="less （一页一页翻动）"></a>less （一页一页翻动）</h4><ul><li>空白键 ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串 ：向下搜寻“字串”的功能；</li><li>?字串 ：向上搜寻“字串”的功能；</li><li>n ：重复前一个搜寻 （与 / 或 ? 有关！）</li><li>N ：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li><li>g ：前进到这个数据的第一行去；</li><li>G ：前进到这个数据的最后一行去 （注意大小写）；</li><li>q ：离开 less 这个程序；</li></ul><h3 id="数据撷取"><a href="#数据撷取" class="headerlink" title="数据撷取"></a>数据撷取</h3><h4 id="head-（取出前面几行）"><a href="#head-（取出前面几行）" class="headerlink" title="head （取出前面几行）"></a>head （取出前面几行）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ head [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure><h4 id="tail-（取出后面几行）"><a href="#tail-（取出后面几行）" class="headerlink" title="tail （取出后面几行）"></a>tail （取出后面几行）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ tail [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：后面接数字，代表显示几行的意思</span><br><span class="line">-f ：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非纯文本文件：-od"><a href="#非纯文本文件：-od" class="headerlink" title="非纯文本文件： od"></a>非纯文本文件： od</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ od [-t TYPE] 文件</span><br><span class="line">选项或参数：</span><br><span class="line">-t ：后面可以接各种“类型 （TYPE）”的输出，例如：</span><br><span class="line">    a ：利用默认的字符来输出；</span><br><span class="line">    c ：使用 ASCII 字符来输出</span><br><span class="line">    d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes；</span><br><span class="line">    f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes；</span><br><span class="line">    o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes；</span><br><span class="line">    x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes；</span><br></pre></td></tr></table></figure><h3 id="修改文件时间或创建新文件：-touch"><a href="#修改文件时间或创建新文件：-touch" class="headerlink" title="修改文件时间或创建新文件： touch"></a>修改文件时间或创建新文件： touch</h3><p>linux文件的三个时间：</p><ol><li>modification time （mtime）： 当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li><li>status time （ctime）： 当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li><li>access time （atime）： 当“该文件的内容被取用”时，就会更新这个读取时间（access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的atime 了。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ touch [-acdmt] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：仅修订 access time；</span><br><span class="line">-c ：仅修改文件的时间，若该文件不存在则不创建新文件；</span><br><span class="line">-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=<span class="string">&quot;日期或时间&quot;</span></span><br><span class="line">-m ：仅修改 mtime ；</span><br><span class="line">-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure><h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">umask</span></span><br><span class="line">0022 &lt;==与一般权限有关的是后面三个数字！</span><br><span class="line">[root@study ~]$ <span class="built_in">umask</span> -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><ul><li>umask的利用与重要性：专题制作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">umask</span> 002</span><br><span class="line">[root@study ~]$ touch test3</span><br><span class="line">[root@study ~]$ mkdir test4</span><br><span class="line">[root@study ~]$ ll -d <span class="built_in">test</span>[34] <span class="comment"># 中括号 [ ] 代表中间有个指定的字符，而不是任意字符的意思</span></span><br><span class="line">-rw-rw-r--. 1 root root 0 6月 16 01:12 test3</span><br><span class="line">drwxrwxr-x. 2 root root 6 6月 16 01:12 test4</span><br></pre></td></tr></table></figure><blockquote><p>umask 对于新建文件与目录的默认权限是很有关系的！这个概念可以用在任何服务器上面， 尤其是未来在你架设文件服务器 （file server） ，举例来说， SAMBA Server或者是 FTP server 时， 都是很重要的观念！这牵涉到你的使用者是否能够将文件进一步利用的问题喔！不要等闲视之！</p></blockquote><h3 id="文件隐藏属性"><a href="#文件隐藏属性" class="headerlink" title="文件隐藏属性"></a>文件隐藏属性</h3><blockquote><p>chattr指令只能在Ext2/Ext3/Ext4的 Linux 传统文件系统上面完整生效， 其他的文件系统可能<br>就无法完整的支持这个指令了，例如 xfs 仅支持部份参数而已。</p></blockquote><h4 id="chattr-（设置文件隐藏属性）"><a href="#chattr-（设置文件隐藏属性）" class="headerlink" title="chattr （设置文件隐藏属性）"></a>chattr （设置文件隐藏属性）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ chattr [+-=][ASacdistu] 文件或目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">+ ：增加某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">- ：移除某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">= ：设置一定，且仅有后面接的参数</span><br><span class="line">A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）</span><br><span class="line">S ：一般文件是非同步写入磁盘的（原理请参考[前一章sync](../Text/index.html<span class="comment">#sync)的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。</span></span><br><span class="line">a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性</span><br><span class="line">c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩，但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）</span><br><span class="line">d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份</span><br><span class="line">i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！”</span><br><span class="line">    对于系统安全性有相当大的助益！只有 root 能设置此属性</span><br><span class="line">s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，所以如果误删了，完全无法救回来了喔！</span><br><span class="line">u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，可以使用来救援该文件喔！</span><br><span class="line">注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置</span><br><span class="line">注意2：xfs 文件系统仅支持 AadiS 而已</span><br></pre></td></tr></table></figure><h4 id="lsattr-（显示文件隐藏属性）"><a href="#lsattr-（显示文件隐藏属性）" class="headerlink" title="lsattr （显示文件隐藏属性）"></a>lsattr （显示文件隐藏属性）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ lsattr [-adR] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-a ：将隐藏文件的属性也秀出来；</span><br><span class="line">-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；</span><br><span class="line">-R ：连同子目录的数据也一并列出来！</span><br></pre></td></tr></table></figure><h3 id="文件特殊权限：-SUID-SGID-SBIT"><a href="#文件特殊权限：-SUID-SGID-SBIT" class="headerlink" title="文件特殊权限： SUID, SGID, SBIT"></a>文件特殊权限： SUID, SGID, SBIT</h3><h4 id="Set-UID"><a href="#Set-UID" class="headerlink" title="Set UID"></a>Set UID</h4><p>当 s 这个标志出现在文件拥有者的 x 权限上时，例如刚刚提到的 /usr/bin/passwd 这个文件的权限状态：“-rwsr-xr-x”，此时就被称为 Set UID，简称为 SUID 的特殊权限。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/15/CwAVepj3aNsT4KG.png" alt="SUID程序执行的过程示意图"></p><ul><li>SUID 权限仅对二进制程序（binary program）有效；</li><li>执行者对于该程序需要具有 x 的可执行权限；</li><li>本权限仅在执行该程序的过程中有效 （run-time）；</li><li>执行者将具有该程序拥有者 （owner） 的权限。</li><li>SUID 不能用在shell script和目录上面。</li></ul><h4 id="Set-GID"><a href="#Set-GID" class="headerlink" title="Set GID"></a>Set GID</h4><p>当s 在群组的 x 时则称为 Set GID, SGID</p><p>与 SUID 不同的是，SGID 可以针对文件或目录来设置！</p><p>对文件来说：</p><ul><li>SGID 对二进制程序有用；</li><li>程序执行者对于该程序来说，需具备 x 的权限；</li><li>执行者在执行的过程中将会获得该程序群组的支持！</li></ul><p>对目录来说：</p><ul><li>使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录；</li><li>使用者在此目录下的有效群组（effective group）将会变成该目录的群组；</li><li>用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。</li></ul><h4 id="Sticky-Bit"><a href="#Sticky-Bit" class="headerlink" title="Sticky Bit"></a>Sticky Bit</h4><p>Sticky Bit, SBIT 目前只针对目录有效。</p><p>作用是:</p><ul><li>当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时；</li><li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件</li></ul><h4 id="SUID-SGID-SBIT-权限设置"><a href="#SUID-SGID-SBIT-权限设置" class="headerlink" title="SUID/SGID/SBIT 权限设置"></a>SUID/SGID/SBIT 权限设置</h4><ul><li>4 为 SUID</li><li>2 为 SGID</li><li>1 为 SBIT</li></ul><p>假设要将一个文件权限改为<code>-rwsr-xr-x</code>时，由于 s 在使用者权限中，所以是 SUID ，因此，在原先的 755 之前还要加上 4 ，也就是：<code>chmod 4755 filename</code> 来设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">cd</span> /tmp</span><br><span class="line">[root@study tmp]$ touch <span class="built_in">test</span> &lt;==创建一个测试用空档</span><br><span class="line">[root@study tmp]$ chmod 4755 <span class="built_in">test</span>; ls -l <span class="built_in">test</span> &lt;==加入具有 SUID 的权限</span><br><span class="line">-rwsr-xr-x 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br><span class="line">[root@study tmp]$ chmod 6755 <span class="built_in">test</span>; ls -l <span class="built_in">test</span> &lt;==加入具有 SUID/SGID 的权限</span><br><span class="line">-rwsr-sr-x 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br><span class="line">[root@study tmp]$ chmod 1755 <span class="built_in">test</span>; ls -l <span class="built_in">test</span> &lt;==加入 SBIT 的功能！</span><br><span class="line">-rwxr-xr-t 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br><span class="line">[root@study tmp]$ chmod 7666 <span class="built_in">test</span>; ls -l <span class="built_in">test</span> &lt;==具有空的 SUID/SGID 权限</span><br><span class="line">-rwSrwSrwT 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>最后一个例子出现大写的 S 与 T ，是因为 s 与 t都是取代 x 这个权限的，但是下达的权限是 7666，也就是说， user,group 以及 others 都没有 x 这个可执行的标志（ 因为 666 ），所以，这个 S, T 代表的就是“空的”，即都没有执行权限。</p><blockquote><p>SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t 符号法</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置权限成为 -rws--x--x 的模样：</span></span><br><span class="line">[root@study tmp]$ chmod u=rwxs,go=x <span class="built_in">test</span>; ls -l <span class="built_in">test</span></span><br><span class="line">-rws--x--x 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 承上，加上 SGID 与 SBIT 在上述的文件权限中！</span></span><br><span class="line">[root@study tmp]$ chmod g+s,o+t <span class="built_in">test</span>; ls -l <span class="built_in">test</span></span><br><span class="line">-rws--s--t 1 root root 0 Jun 16 02:53 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="观察文件类型：file"><a href="#观察文件类型：file" class="headerlink" title="观察文件类型：file"></a>观察文件类型：file</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ file ~/.bashrc</span><br><span class="line">/root/.bashrc: ASCII text &lt;==告诉我们是 ASCII 的纯文本文件啊！</span><br><span class="line">[root@study ~]$ file /usr/bin/passwd</span><br><span class="line">/usr/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 （SYSV）, dynamically</span><br><span class="line">linked （uses shared libs）, <span class="keyword">for</span> GNU/Linux 2.6.32,</span><br><span class="line">BuildID[sha1]=0xbf35571e607e317bf107b9bcf65199988d0ed5ab, stripped</span><br><span class="line"><span class="comment"># 可执行文件的数据可就多的不得了！包括这个文件的 suid 权限、相容于 Intel x86-64 等级的硬件平台</span></span><br><span class="line"><span class="comment"># 使用的是 Linux 核心 2.6.32 的动态函数库链接等等。</span></span><br><span class="line">[root@study ~]$ file /var/lib/mlocate/mlocate.db</span><br><span class="line">/var/lib/mlocate/mlocate.db: data &lt;== 这是 data 文件！</span><br></pre></td></tr></table></figure><h2 id="指令与文件的搜寻"><a href="#指令与文件的搜寻" class="headerlink" title="指令与文件的搜寻"></a>指令与文件的搜寻</h2><h3 id="指令文件名的搜寻"><a href="#指令文件名的搜寻" class="headerlink" title="指令文件名的搜寻"></a>指令文件名的搜寻</h3><ul><li>which （寻找“可执行文件”）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ <span class="built_in">which</span> [-a] <span class="built_in">command</span></span><br><span class="line">选项或参数：</span><br><span class="line">-a ：将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称</span><br></pre></td></tr></table></figure><h3 id="文件文件名的搜寻"><a href="#文件文件名的搜寻" class="headerlink" title="文件文件名的搜寻"></a>文件文件名的搜寻</h3><h4 id="whereis-（由一些特定的目录中寻找文件文件名）"><a href="#whereis-（由一些特定的目录中寻找文件文件名）" class="headerlink" title="whereis （由一些特定的目录中寻找文件文件名）"></a>whereis （由一些特定的目录中寻找文件文件名）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ whereis [-bmsu] 文件或目录名</span><br><span class="line">选项与参数：</span><br><span class="line">-l :可以列出 whereis 会去查询的几个主要目录而已</span><br><span class="line">-b :只找 binary 格式的文件</span><br><span class="line">-m :只找在说明文档 manual 路径下的文件</span><br><span class="line">-s :只找 <span class="built_in">source</span> 来源文件</span><br><span class="line">-u :搜寻不在上述三个项目当中的其他特殊文件</span><br></pre></td></tr></table></figure><h4 id="locate-updatedb"><a href="#locate-updatedb" class="headerlink" title="locate / updatedb"></a>locate / updatedb</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ locate [-ir] keyword</span><br><span class="line">选项与参数：</span><br><span class="line">-i ：忽略大小写的差异；</span><br><span class="line">-c ：不输出文件名，仅计算找到的文件数量</span><br><span class="line">-l ：仅输出几行的意思，例如输出五行则是 -l 5</span><br><span class="line">-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等</span><br><span class="line">-r ：后面可接正则表达式的显示方式</span><br></pre></td></tr></table></figure><p>更新 locate 数据库直接输入<code>updatedb</code>就可以了！</p><p><code>updatedb</code> 指令会去读取 <code>/etc/updatedb.conf</code> 这个配置文件的设置，然后再去硬盘里面进行搜寻文件名的动作， 最后就更新整个数据库文件啰！因为 <code>updatedb</code> 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p><ul><li><code>updatedb</code>：根据 <code>/etc/updatedb.conf</code> 的设置去搜寻系统硬盘内的文件名，并更新<code>/var/lib/mlocate</code> 内的数据库文件；</li><li><code>locate</code>：依据 <code>/var/lib/mlocate</code> 内的数据库记载，找出使用者输入的关键字文件名。</li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ find [PATH] [option] [action]</span><br><span class="line">选项与参数：</span><br><span class="line">1\. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明</span><br><span class="line">    -mtime n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；</span><br><span class="line">    -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；</span><br><span class="line">    -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。</span><br><span class="line">    -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名</span><br><span class="line"></span><br><span class="line">2\. 与使用者或群组名称有关的参数：</span><br><span class="line">    -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在/etc/passwd 里面与帐号名称对应的数字。</span><br><span class="line">    -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group，相关的介绍我们会第四篇说明～</span><br><span class="line">    -user name ：name 为使用者帐号名称喔！例如 dmtsai</span><br><span class="line">    -group name：name 为群组名称喔，例如 users ；</span><br><span class="line">    -nouser ：寻找文件的拥有者不存在 /etc/passwd 的人！</span><br><span class="line">    -nogroup ：寻找文件的拥有群组不存在于 /etc/group 的文件！</span><br><span class="line">    当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。</span><br><span class="line"></span><br><span class="line">3\. 与文件权限及名称有关的参数：</span><br><span class="line">    -name filename：搜寻文件名称为 filename 的文件；</span><br><span class="line">    -size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：</span><br><span class="line">    c: 代表 Byte， k: 代表 1024Bytes。所以，要找比 50KB</span><br><span class="line">还要大的文件，就是“ -size +50k ”</span><br><span class="line">    -<span class="built_in">type</span> TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）,目录 （d）, 链接文件（l）, socket （s）, 及 FIFO （p） 等属性。</span><br><span class="line">    -perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！</span><br><span class="line">    -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说，我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744，当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。</span><br><span class="line">    -perm /mode ：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻-rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！</span><br><span class="line"></span><br><span class="line">4\. 额外可进行的动作：</span><br><span class="line">    -<span class="built_in">exec</span> <span class="built_in">command</span> ：<span class="built_in">command</span> 为其他指令，-<span class="built_in">exec</span> 后面可再接额外的指令来处理搜寻到的结果。</span><br><span class="line">    -<span class="built_in">print</span> ：将结果打印到屏幕上，这个动作是默认动作！</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/15/FHDNTPkEy2lKA8o.png" alt="find 相关的时间参数意义"></p><ul><li>+4代表大于等于5天前的文件名：<code>ex&gt; find /var -mtime +4</code></li><li>-4代表小于等于4天内的文件文件名：<code>ex&gt; find /var -mtime -4</code></li><li>4则是代表4-5那一天的文件文件名：<code>ex&gt; find /var -mtime 4</code></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/15/uYrJCxepsDLOi2S.png" alt="find 相关的额外动作"></p><p>该范例中特殊的地方有 <code>&#123;&#125;</code> 以及 <code>\</code>; 还有 <code>-exec</code> 这个关键字，这些东西的意义为：</p><ul><li><code>&#123;&#125;</code> 代表的是“由 find 找到的内容”，如上图所示，<code>find</code> 的结果会被放置到 <code>&#123;&#125;</code> 位置中；</li><li><code>-exec</code> 一直到 <code>\;</code> 是关键字，代表 <code>find</code> 额外动作的开始 <code>-exec</code> 到结束 <code>\;</code> ，在这中间的就是 find 指令内的额外动作。 在本例中就是 <code>ls -l &#123;&#125;</code> 啰！</li><li>因为 <code>;</code> 在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。</li></ul><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><ol><li><p>让使用者能进入某目录成为“可工作目录”的基本权限为何：</p><ul><li>可使用的指令：例如 cd 等变换工作目录的指令；</li><li>目录所需权限：使用者对这个目录至少需要具有 x 的权限</li><li>额外需求：如果使用者想要在这个目录内利用 ls 查阅文件名，则使用者对此目录还需要 r的权限。</li></ul></li><li><p>使用者在某个目录内读取一个文件的基本权限为何？</p><ul><li>可使用的指令：例如本章谈到的 cat, more, less等等</li><li>目录所需权限：使用者对这个目录至少需要具有 x 权限；</li><li>文件所需权限：使用者对文件至少需要具有 r 的权限才行！</li></ul></li><li><p>让使用者可以修改一个文件的基本权限为何？</p><ul><li>可使用的指令：例如 nano 或未来要介绍的 vi 编辑器等；</li><li>目录所需权限：使用者在该文件所在的目录至少要有 x 权限；</li><li>文件所需权限：使用者对该文件至少要有 r, w 权限</li></ul></li><li><p>让一个使用者可以创建一个文件的基本权限为何？</p><ul><li>目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！</li></ul></li><li><p>让使用者进入某目录并执行该目录下的某个指令之基本权限为何？</p><ul><li>目录所需权限：使用者在该目录至少要有 x 的权限；</li><li>文件所需权限：使用者在该文件至少需要有 x 的权限</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件 </tag>
            
            <tag> 目录管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 的文件权限与目录配置</title>
      <link href="/2020/09/10/Linux%20%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/10/Linux%20%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Linux一般将文件可存取的身份分为三个类别，分别是 owner/group/others，且三种身份各有 read/write/execute 等权限。</p></blockquote><h2 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h2><h3 id="文件拥有者"><a href="#文件拥有者" class="headerlink" title="文件拥有者"></a>文件拥有者</h3><p>由于Linux是个多用户多任务的系统, 所以可以设置为只有文件拥有者才可查看或修改，其他人无法查看修改</p><h3 id="群组概念"><a href="#群组概念" class="headerlink" title="群组概念"></a>群组概念</h3><p>以团队形式来共享，分隔可查看，修改的权限。</p><h3 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h3><p>既不是文件拥有者，又不是群组里的人，root除外。</p><h3 id="Linux-使用者身份与群组记录的文件"><a href="#Linux-使用者身份与群组记录的文件" class="headerlink" title="Linux 使用者身份与群组记录的文件"></a>Linux 使用者身份与群组记录的文件</h3><p>默认的情况下：</p><ol><li>所有的系统上的帐号与一般身份使用者，还有root， 记录在 <code>/etc/passwd</code></li><li>个人的密码则是记录在 <code>/etc/shadow</code> </li><li>Linux所有的群组名称都纪录在 <code>/etc/group</code></li></ol><h2 id="Linux-文件权限概念"><a href="#Linux-文件权限概念" class="headerlink" title="Linux 文件权限概念"></a>Linux 文件权限概念</h2><h3 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/ls.jpg" alt="ls -al"></p><ol><li><p>第一栏代表这个文件的类型与权限（permission）</p><p> <img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/permission.jpg" alt="文件的类型与权限之内容"></p><ol><li><p>第一个字符代表这个文件是“目录、文件或链接文件等等”：</p><ul><li>当为<code>d</code>则是目录，例如上表文件名为“.config”的那一行；</li><li>当为<code>-</code>则是文件，例如上表文件名为“initial-setup-ks.cfg”那一行；</li><li>若是<code>l</code>则表示为链接文件（link file）；</li><li>若是<code>b</code>则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；</li><li>若是<code>c</code>则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</li></ul></li><li><p>接下来的字符中，以三个为一组，且均为“rwx” 的三个参数的组合。</p><ul><li><code>r</code>代表可读（read）、<code>w</code>代表可写（write）、<code>x</code>代表可执行（execute）</li><li>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号<code>-</code>而已。</li><li>第一组为“文件拥有者可具备的权限”，以“initial-setup-ks.cfg”那个文件为例， 该文件的拥有者可以读写，但不可执行；</li><li>第二组为“加入此群组之帐号的权限”；</li><li>第三组为“非本人且没有加入本群组之其他帐号的权限”。</li></ul></li></ol></li><li><p>第二栏表示有多少文件名链接到此节点（i-node）</p></li><li><p>第三栏表示这个文件（或目录）的“拥有者帐号”</p></li><li><p>第四栏表示这个文件的所属群组</p></li><li><p>第五栏为这个文件的容量大小，默认单位为Bytes；</p></li><li><p>第六栏为这个文件的创建日期或者是最近的修改日期</p></li><li><p>第七栏为这个文件的文件名</p></li></ol><h3 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h3><ul><li>chgrp ：改变文件所属群组</li><li>chown ：改变文件拥有者</li><li>chmod ：改变文件的权限, <code>SUID, SGID, SBIT</code>等等的特性</li></ul><h4 id="改变所属群组-chgrp"><a href="#改变所属群组-chgrp" class="headerlink" title="改变所属群组, chgrp"></a>改变所属群组, chgrp</h4><ul><li>被改变的群组名称必须要在<code>/etc/group</code>文件内存在才行，否则就会显示错误</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ chgrp [-R] dirname/filename ...</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件、目录</span><br><span class="line">都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。</span><br><span class="line">范例：</span><br><span class="line">[root@study ~]$ chgrp users initial-setup-ks.cfg</span><br><span class="line">[root@study ~]$ ls -l</span><br><span class="line">-rw-r--r--. 1 root users 1864 May 4 18:01 initial-setup-ks.cfg</span><br><span class="line">[root@study ~]$ chgrp testing initial-setup-ks.cfg</span><br><span class="line">chgrp: invalid group: testing</span><br></pre></td></tr></table></figure><h4 id="改变文件拥有者-chown"><a href="#改变文件拥有者-chown" class="headerlink" title="改变文件拥有者, chown"></a>改变文件拥有者, chown</h4><ul><li>在<code>/etc/passwd</code>这个文件中有纪录的使用者名称才能改变</li><li>可以顺便直接修改群组的名称<code>chown [-R] 帐号名称:群组名称 文件或目录</code></li><li><code>:</code> 可以用 <code>.</code> 替换, 推荐 <code>:</code></li><li>chown也能单纯的修改所属群组呢！ 例如<code>chown .sshd initial-setup-ks.cfg</code>就是修改群组，就是那个小数点的用途！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]<span class="comment"># chown [-R] 帐号名称 文件或目录</span></span><br><span class="line">[root@study ~]<span class="comment"># chown [-R] 帐号名称:群组名称 文件或目录</span></span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者改为bin这个帐号：</span><br><span class="line">[root@study ~]<span class="comment"># chown bin initial-setup-ks.cfg</span></span><br><span class="line">[root@study ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--. 1 bin users 1864 May 4 18:01 initial-setup-ks.cfg</span><br><span class="line">范例：将 initial-setup-ks.cfg 的拥有者与群组改回为root：</span><br><span class="line">[root@study ~]<span class="comment"># chown root:root initial-setup-ks.cfg</span></span><br><span class="line">[root@study ~]<span class="comment"># ls -l</span></span><br><span class="line">-rw-r--r--. 1 root root 1864 May 4 18:01 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure><h4 id="改变权限-chmod"><a href="#改变权限-chmod" class="headerlink" title="改变权限, chmod"></a>改变权限, chmod</h4><ol><li><p>数字类型改变文件权限</p><blockquote><p><code>r, w, x</code> 分别对应数字 4, 2, 1</p></blockquote><p> 每种身份（owner/group/others）各自的三个权限（r/w/x）分数是需要累加的，例如当权限为：<code>-rwxrwx---</code> 分数则是：</p><blockquote><p><code>owner = rwx = 4+2+1 = 7 &gt; group = rwx = 4+2+1 = 7 &gt; others= --- = 0+0+0 = 0</code>  即该文件权限为770</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]$ chmod [-R] xyz 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回（recursive）的持续变更，亦即连同次目录下的所有文件都会变更</span><br></pre></td></tr></table></figure><ul><li>vim编辑后的文件默认是664 —— <code>-rw-rw-r--</code></li><li>需要变成可执行文件是755 —— <code>-rwxr-xr-x</code></li></ul></li><li><p>符号类型改变文件权限</p><blockquote><p>user, group, others, all 分别对应字母 u, g, o, a</p></blockquote><ul><li>| chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 |</li></ul></li></ol><h3 id="目录与文件之权限意义"><a href="#目录与文件之权限意义" class="headerlink" title="目录与文件之权限意义"></a>目录与文件之权限意义</h3><p>一个文件可以具有的权限有：可读、可写、可执行权限</p><table><thead><tr><th>权限</th><th>具体内容</th></tr></thead><tbody><tr><td>r</td><td>可读权限—read<br>对文件：具有显示文件内容的权限<br>对目录：具有浏览目录的权限，可以查看目录内容，但是无法进入目录</td></tr><tr><td>w</td><td>可写权限—write<br>对文件：具有编辑和删除文件的权限<br>对目录：具有删除和移动目录的权限</td></tr><tr><td>x</td><td>可执行权限—excute<br>对文件：具有执行文件的权限<br>对目录：具有进入目录的权限</td></tr></tbody></table><h3 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a>Linux文件种类与扩展名</h3><table><thead><tr><th>文件种类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>正规文件（regular file）</td><td>第一个属性为 <code>-</code></td><td>纯文本文件（ASCII）<br>二进制档（binary）<br>数据格式文件（data）</td></tr><tr><td>目录（directory）</td><td>第一个属性为 <code>d</code></td><td>如 [drwxrwxrwx]</td></tr><tr><td>链接文件（link）</td><td>第一个属性为 <code>l</code></td><td>类似Windows中的快捷方式</td></tr><tr><td>设备与设备文件（device）</td><td>第一个属性为<code>b</code><br>第一个属性为<code>c</code></td><td>区块（block）设备文件 储存设备<br>字符（character）设备文件 外设</td></tr><tr><td>数据接口文件（sockets）</td><td>第一个属性为 <code>s</code></td><td>最常在/run或/tmp这些个目录中看到这种文件类型</td></tr><tr><td>数据输送档（FIFO, pipe）</td><td>第一个属性为<code>p</code></td><td>目的在解决多个程序同时存取一个文件所造成的错误问题</td></tr></tbody></table><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><h3 id="Linux目录配置的依据–FHS"><a href="#Linux目录配置的依据–FHS" class="headerlink" title="Linux目录配置的依据–FHS"></a>Linux目录配置的依据–FHS</h3><p>Filesystem Hierarchy Standard （FHS）标准</p><ul><li><code>/</code> （root, 根目录）：与开机系统有关；</li><li><code>/usr</code> （unix software resource）：与软件安装/执行有关；</li><li><code>/var</code> （variable）：与系统运行过程有关。</li></ul><h4 id="根目录-（-）-的意义与内容"><a href="#根目录-（-）-的意义与内容" class="headerlink" title="根目录 （/） 的意义与内容"></a>根目录 （/） 的意义与内容</h4><table><thead><tr><th></th><th>可分享的（shareable）</th><th>不可分享的（unshareable）</th></tr></thead><tbody><tr><td>不变的（static）</td><td><code>/usr</code> （软件放置处）</td><td><code>/etc</code> （配置文件）</td></tr><tr><td></td><td><code>/opt</code> （第三方协力软件）</td><td><code>/boot</code> （开机与核心档）</td></tr><tr><td>可变动的（variable）</td><td><code>/var/mail</code> （使用者邮件信箱）</td><td><code>/var/run</code> （程序关）</td></tr><tr><td></td><td><code>/var/spool/news</code> （新闻群组）</td><td><code>/var/lock</code> （程序相关）</td></tr></tbody></table><blockquote><p>具体内容参看鸟哥Linux私房菜第四版p281</p></blockquote><ul><li>根目录越小越好。 如此不但性能较佳，根目录所在的文件系统也较不容易发生问题。</li></ul><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/lost+found</td><td>这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</td></tr><tr><td>/proc</td><td>这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>,<code>/proc/interrupts</code>,<code> /proc/ioports</code>, <code>/proc/net/*</code> 等等。</td></tr><tr><td>/sys</td><td>这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔</td></tr></tbody></table><h4 id="usr-的意义与内容"><a href="#usr-的意义与内容" class="headerlink" title="/usr 的意义与内容"></a>/usr 的意义与内容</h4><blockquote><p>usr是Unix Software Resource,也就是“Unix操作系统软件资源”所放置的目录,所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p></blockquote><h4 id="var-的意义与内容"><a href="#var-的意义与内容" class="headerlink" title="/var 的意义与内容"></a>/var 的意义与内容</h4><blockquote><p>/var目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file,run file），或者例如MySQL数据库的文件等等。</p></blockquote><p>CentOS 7 与过去的目录编排：</p><ul><li>/bin –&gt; /usr/bin</li><li>/sbin –&gt; /usr/sbin</li><li>/lib –&gt; /usr/lib</li><li>/lib64 –&gt; /usr/lib64</li><li>/var/lock –&gt; /run/lock</li><li>/var/run –&gt; /run</li></ul><h3 id="目录树（directory-tree）"><a href="#目录树（directory-tree）" class="headerlink" title="目录树（directory tree）"></a>目录树（directory tree）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/09/10/LiGJy8qmjgOQSPe.png" alt="目录树架构示意图"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件权限 </tag>
            
            <tag> 目录配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>man page &amp; info page</title>
      <link href="/2020/09/10/man%20page%20&amp;%20info%20page/"/>
      <url>/2020/09/10/man%20page%20&amp;%20info%20page/</url>
      
        <content type="html"><![CDATA[<h2 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h2><h3 id="常见数字"><a href="#常见数字" class="headerlink" title="常见数字"></a>常见数字</h3><table><thead><tr><th>代号</th><th>代表内容</th></tr></thead><tbody><tr><td>1</td><td>使用者在shell环境中可以操作的指令或可可执行文件</td></tr><tr><td>2</td><td>系统核心可调用的函数与工具等</td></tr><tr><td>3</td><td>一些常用的函数（function）与函数库（library），大部分为C的函数库（libc）</td></tr><tr><td>4</td><td>设备文件的说明，通常在/dev下的文件</td></tr><tr><td>5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td>6</td><td>游戏（games）</td></tr><tr><td>7</td><td>惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明</td></tr><tr><td>8</td><td>系统管理员可用的管理指令</td></tr><tr><td>9</td><td>跟kernel有关的文件</td></tr></tbody></table><ul><li>上述的表格内容可以使用“man man”来更详细的取得说明。</li></ul><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><table><thead><tr><th>代号</th><th>内容说明</th></tr></thead><tbody><tr><td>NAME</td><td>简短的指令、数据名称说明</td></tr><tr><td>SYNOPSIS</td><td>简短的指令下达语法（syntax）简介</td></tr><tr><td>DESCRIPTION</td><td>较为完整的说明，这部分最好仔细看看！</td></tr><tr><td>OPTIONS</td><td>针对 SYNOPSIS 部分中，有列举的所有可用的选项说明</td></tr><tr><td>COMMANDS</td><td>当这个程序（软件）在执行的时候，可以在此程序（软件）中下达的指令</td></tr><tr><td>FILES</td><td>这个程序或数据所使用或参考或链接到的某些文件</td></tr><tr><td>SEE ALSO</td><td>可以参考的，跟这个指令或数据有相关的其他说明！</td></tr><tr><td>EXAMPLE</td><td>一些可以参考的范例</td></tr></tbody></table><h3 id="查看步骤"><a href="#查看步骤" class="headerlink" title="查看步骤"></a>查看步骤</h3><ol><li>先察看NAME的项目，约略看一下这个数据的意思；</li><li>再详看一下DESCRIPTION，这个部分会提到很多相关的数据与使用时机，从这个地方可以学到很多小细节呢；</li><li>而如果这个指令其实很熟悉了（例如上面的date），那么鸟哥主要就是查询关于OPTIONS的部分了！ 可以知道每个选项的意义，这样就可以下达比较细部的指令内容呢！</li><li>最后，鸟哥会再看一下，跟这个数据有关的还有哪些东西可以使用的？举例来说，上面的SEE ALSO就告知我们还可以利用“info coreutils date”来进一步查阅数据；</li><li>某些说明内容还会列举有关的文件（FILES 部分）来提供我们参考！这些都是很有帮助的！</li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻一页</td></tr><tr><td>[PageDown]</td><td>向下翻一页</td></tr><tr><td>[PageUp]</td><td>向上翻一页</td></tr><tr><td>[Home]</td><td>去到第一页</td></tr><tr><td>[End]</td><td>去到最后一页</td></tr><tr><td>/string</td><td>向“下”搜寻 string 这个字串</td></tr><tr><td>?string</td><td>向“上”搜寻 string 这个字串</td></tr><tr><td>n, N</td><td>利用 / 或 ? 来搜寻字串时，可以用 n 来继续下一个搜寻 （不论是 / 或 ?），可以利用 N 来进行“反向”搜寻。</td></tr><tr><td>q</td><td>结束这次的 man page</td></tr></tbody></table><h3 id="特殊查询"><a href="#特殊查询" class="headerlink" title="特殊查询"></a>特殊查询</h3><ol><li>查询<code>man</code>这个指令有关的说明文档 <code>-f</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[blackgane@study ~]$ man -f man</span><br><span class="line">man （1） - an interface to the on-line reference manuals</span><br><span class="line">man （1p） - display system documentation</span><br><span class="line">man （7） - macros to format man pages</span><br></pre></td></tr></table></figure><ol start="2"><li>查询<code>man</code>这个关键词的说明文档 <code>-k</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[blackgane@study ~]$ man -k man</span><br><span class="line">fallocate （2） - manipulate file space</span><br><span class="line">zshall （1） - the Z shell meta-man page</span><br><span class="line">....（中间省略）....</span><br><span class="line">yum-config-manager （1） - manage yum configuration options and yum repositories</span><br></pre></td></tr></table></figure><h2 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h2><h3 id="数据意义"><a href="#数据意义" class="headerlink" title="数据意义"></a>数据意义</h3><ol><li>File：代表这个info page的数据是来自info.info文件所提供的；</li><li>Node：代表目前的这个页面是属于Top节点。 意思是info.info内含有很多信息，而Top仅是info.info文件内的一个节点内容而已；</li><li>Next：下一个节点的名称为Getting Started，你也可以按“N”到下个节点去；</li><li>Up：回到上一层的节点总揽画面，你也可以按下“U”回到上一层；</li><li>Prev：前一个节点。但由于Top是info.info的第一个节点，所以上面没有前一个节点的信息。</li></ol><h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>按键</th><th>进行工作</th></tr></thead><tbody><tr><td>空白键</td><td>向下翻一页</td></tr><tr><td>[Page Down]</td><td>向下翻一页</td></tr><tr><td>[Page Up]</td><td>向上翻一页</td></tr><tr><td>[tab]</td><td>在 node 之间移动，有 node 的地方，通常会以 * 显示。</td></tr><tr><td>[Enter]</td><td>当光标在 node 上面时，按下 Enter 可以进入该 node 。</td></tr><tr><td>b</td><td>移动光标到该 info 画面当中的第一个 node 处</td></tr><tr><td>e</td><td>移动光标到该 info 画面当中的最后一个 node 处</td></tr><tr><td>n</td><td>前往下一个 node 处</td></tr><tr><td>p</td><td>前往上一个 node 处</td></tr><tr><td>u</td><td>向上移动一层</td></tr><tr><td>s（/）</td><td>在 info page 当中进行搜寻</td></tr><tr><td>h, ?</td><td>显示求助菜单</td></tr><tr><td>q</td><td>结束这次的 info page</td></tr></tbody></table><h2 id="其他有用的文件"><a href="#其他有用的文件" class="headerlink" title="其他有用的文件"></a>其他有用的文件</h2><blockquote><p>很多原版软件释出的时候，都会有一些安装须知、预计工作事项、未来工作规划等等的东西，还有包括可安装的程序等， 这些文件也都放置在 /usr/share/doc 当中</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ManPage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装CentOS7</title>
      <link href="/2020/09/09/%E5%AE%89%E8%A3%85CentOS7/"/>
      <url>/2020/09/09/%E5%AE%89%E8%A3%85CentOS7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下载链接：<a href="http://vault.centos.org/7.1.1503/isos/x86_64/">http://vault.centos.org/7.1.1503/isos/x86_64/</a></p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>调整开机媒体（BIOS）：务必要使用CD或DVD光盘开机，通常需要调整BIOS；</li><li>选择安装模式与开机：包括图形接口/命令行等，也可加入特殊参数来开机进入安装画面；</li><li>选择语系数据：由于不同地区的键盘按键不同，此时需要调整语系/键盘/鼠标等配备；</li><li>软件选择：需要什么样的软件？全部安装还是默认安装即可？</li><li>磁盘分区：最重要的项目之一了！记得将刚刚的规划单拿出来设置；</li><li>开机管理程序、网络、时区设置与root密码：一些需要的系统基础设置！</li><li>安装后的首次设置：安装完毕后还有一些事项要处理，包括使用者、SELinux与防火墙等！</li></ol><h3 id="加入强制使用-GPT-分区表的安装参数"><a href="#加入强制使用-GPT-分区表的安装参数" class="headerlink" title="加入强制使用 GPT 分区表的安装参数"></a>加入强制使用 GPT 分区表的安装参数</h3><ol><li>使用方向键，将图 3.2.8 的光标移动到“ Install CentOS 7 ”的项目中</li><li>按下键盘的 <code>Tab</code> 按钮，让光标跑到画面最下方等待输入额外的核心参数</li><li>在出现的画面中，输入如下画面的数据 （注意，各个项目要有空格，最后一个是光标本身而非底线）</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/gpt.jpg" alt="加入额外的核心参数修改安装程序"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux主机规划与磁盘分区</title>
      <link href="/2020/09/07/Linux%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
      <url>/2020/09/07/Linux%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在Linux系统中，每个设备都被当成一个文件来对待</p></blockquote><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><table><thead><tr><th>设备</th><th>设备在Linux内的文件名</th></tr></thead><tbody><tr><td>SCSI/SATA/USB硬盘机</td><td>/dev/sd[a-p]</td></tr><tr><td>USB闪存盘</td><td>/dev/sd[a-p] （与SATA相同）</td></tr><tr><td>VirtI/O界面</td><td>/dev/vd[a-p] （用于虚拟机内）</td></tr><tr><td>软盘机</td><td>/dev/fd[0-7]</td></tr><tr><td>打印机</td><td>/dev/lp[0-2] （25针打印机） /dev/usb/lp[0-15] （USB 接口）</td></tr><tr><td>鼠标</td><td>/dev/input/mouse[0-15] （通用） /dev/psaux （PS/2界面）/dev/mouse （当前鼠标）</td></tr><tr><td>CDROM/DVDROM</td><td>/dev/scd[0-1] （通用） /dev/sr[0-1] （通用，CentOS 较常见）/dev/cdrom （当前 CDROM）</td></tr><tr><td>磁带机</td><td>/dev/ht0 （IDE 界面） /dev/st0 （SATA/SCSI界面） /dev/tape（当前磁带）</td></tr><tr><td>IDE硬盘机</td><td>/dev/hd[a-d] （旧式系统才有）</td></tr></tbody></table><h3 id="MSDOS-（MBR）-分区表格式与限制"><a href="#MSDOS-（MBR）-分区表格式与限制" class="headerlink" title="MSDOS （MBR） 分区表格式与限制"></a>MSDOS （MBR） 分区表格式与限制</h3><p>磁盘的第一个扇区 512Bytes 会有这两个数据：</p><ol><li>主要开机记录区（Master Boot Record, MBR）：可以安装开机管理程序的地方，有446Bytes</li><li>分区表（partition table）：记录整颗硬盘分区的状态，有64 Bytes</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/disk.jpg" alt="磁盘分区表的作用示意图"></p><ul><li>P1:/dev/sda1</li><li>P2:/dev/sda2</li><li>L1:/dev/sda5</li><li>L2:/dev/sda6</li><li>L3:/dev/sda7</li><li>L4:/dev/sda8</li><li>L5:/dev/sda9</li></ul><blockquote><p>怎么设备文件名没有/dev/sda3与/dev/sda4呢？因为前面四个号码都是保留给Primary或Extended用的嘛！ 所以逻辑分区的设备名称号码就由5号开始了！这在 MBR 方式的分区表中是个很重要的特性，不能忘记喔！</p></blockquote><p>MBR 主要分区、延伸分区与逻辑分区的特性：</p><ul><li>主要分区与延伸分区最多可以有四个（硬盘的限制）</li><li>分区表就只有64 Bytes而已，最多只能容纳四笔分区的记录</li><li>延伸分区最多只能有一个（操作系统的限制）</li><li>逻辑分区是由延伸分区持续切割出来的分区；</li><li>能够被格式化后，作为数据存取的分区为主要分区与逻辑分区。延伸分区无法格式化；</li><li>逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制；</li></ul><h3 id="GUID-partition-table-GPT-磁盘分区表"><a href="#GUID-partition-table-GPT-磁盘分区表" class="headerlink" title="GUID partition table, GPT 磁盘分区表"></a>GUID partition table, GPT 磁盘分区表</h3><p>因为过去一个扇区大小就是 512Bytes 而已，不过目前已经有 4K 的扇区设计出现！为了相容于所有的磁盘，因此在扇区的定义上面， 大多会使用所谓的逻辑区块位址（Logical Blockv Address, LBA）来处理。GPT 将磁盘所有区块以此 LBA（默认为 512Bytes 喔！） 来规划，而第一个 LBA 称为 LBA0 （从 0 开始编号）。</p><p>与 MBR 仅使用第一个 512Bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息！同时与过去 MBR 仅有一的区块，被干掉就死光光的情况不同， GPT 除了前面 34 个LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份！这样或许会比较安全些吧！<br>详细的结构有点像下面的模样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/guid_partition_table_scheme.jpg" alt="GUID Partition Table Scheme"></p><ul><li><p>LBA0 （MBR 相容区块）</p><p>  与 MBR 模式相似的，这个相容区块也分为两个部份，一个就是跟之前 446 Bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分区表的纪录区内，这个相容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘喔！</p></li><li><p>LBA1 （GPT 表头纪录）</p><p>  这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 （就是前面谈到的在最后 34 个 LBA 区块） 放置的位置， 同时放置了分区表的检验机制码（CRC32），操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以通过这个纪录区来取得备份的 GPT（磁盘最后的那个备份区块） 来恢复 GPT 的正常运行！</p></li><li><p>LBA2-33 （实际纪录分区信息处）</p><p>  从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 432 = 128 笔分区纪录喔！因为每个 LBA 有512Bytes，因此每笔纪录用到 128Bytes 的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对於单一分区来说，他的最大容量限制就会在“ 264 512Bytes = 263 1KBytes = 233TB = 8 ZB ”，要注意 1ZB= 230TB 啦！ 你说有没有够大了？</p></li></ul><blockquote><p>现在 GPT 分区默认可以提供多达 <strong>128</strong> 笔纪录，而在 Linux 本身的核心设备纪录中，针对单一磁盘来说，虽然过去最多只能到达 15 个分区，不过由于 Linux kernel 通过 udev 等方式的处理，现在 Linux 也已经没有这个限制在了！此外，GPT 分区已经没有所谓的主、延伸、逻辑分区的概念，既然每笔纪录都可以独立存在， 当然每个都可以视为是主分区！每一个分区都可以拿来格式化使用喔！</p></blockquote><p>整个开机流程到操作系统之前的动作应该是这样的：</p><p>BIOS–&gt;MBR–&gt;–&gt;boot loader–&gt;核心文件；</p><ol><li>BIOS：开机主动执行的固件，会认识第一个可开机的设备；</li><li>MBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序；</li><li>开机管理程序（boot loader）：一个可读取核心文件来执行的软件；</li><li>核心文件：开始操作系统的功能…</li></ol><blockquote><p>boot loader的功能主要有：提供菜单、载入核心、转交控制权给其他loader</p></blockquote><blockquote><p>boot loader可以安装的地点有两个，分别是 MBR 与 boot sector</p></blockquote><h2 id="Linux安装模式下，磁盘分区的选择"><a href="#Linux安装模式下，磁盘分区的选择" class="headerlink" title="Linux安装模式下，磁盘分区的选择"></a>Linux安装模式下，磁盘分区的选择</h2><h3 id="目录树结构-（directory-tree）"><a href="#目录树结构-（directory-tree）" class="headerlink" title="目录树结构 （directory tree）"></a>目录树结构 （directory tree）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/directory_tree.jpg" alt="Directory Tree"></p><h3 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h3><p>所谓的“挂载”就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下； 也就是说，进入该目录就可以读取该分区的意思。这个动作我们称为“挂载”，那个进入点的目录我们称为“挂载点”。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/blackgane/cdn_article@master/article_cdn/tree.jpg" alt="目录树与分区之间的相关性"></p><h2 id="安装前规划"><a href="#安装前规划" class="headerlink" title="安装前规划"></a>安装前规划</h2><ol><li>NAT（达成IP分享器的功能）</li><li>SAMBA（加入Windows网络上的芳邻）</li><li>Mail（邮件服务器）</li><li>Web（WWW服务器）</li><li>DHCP（提供用户端自动取得IP的功能）</li><li>FTP</li></ol><p>目录分配</p><ul><li>/boot</li><li>/</li><li>/home</li><li>/var</li><li>Swap</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 磁盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语音标</title>
      <link href="/2020/09/06/DJ%E9%9F%B3%E6%A0%87/"/>
      <url>/2020/09/06/DJ%E9%9F%B3%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<ol><li><a href="https://www.yingyutu.com/dj">DJ音标</a></li><li><a href="https://www.yingyutu.com/kk">KK音标</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
            <tag> 音标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学英语准备工作</title>
      <link href="/2020/09/06/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
      <url>/2020/09/06/%E5%AD%A6%E8%8B%B1%E8%AF%AD%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><a href="http://testyourvocab.com/">词汇量检测</a></li></ol><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><ol><li><p><a href="https://github.com/yujiangshui/A-Programmers-Guide-to-English">A-Programmers-Guide-to-English</a></p></li><li><p><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese">English-level-up-tips-for-Chinese</a></p></li></ol><h3 id="实用Chrome插件"><a href="#实用Chrome插件" class="headerlink" title="实用Chrome插件"></a>实用Chrome插件</h3><ol><li><a href="https://chrome.google.com/webstore/detail/cambridge-dictionary/kjmjndmenaoihimmojhdabgfjefonmja">Cambridge Dictionary</a>：对准单词右击就打开 Cambridge Dictionary 看到对应的词义，用以重度查询</li><li><a href="https://chrome.google.com/webstore/detail/google-dictionary-by-goog/mgijmajocgfcbeboacabfgobmjgjcoja">Google Dictionary (by Google)</a>：双击即可弹出非常简单的弹窗，附带一个英文发音和简短的英文释义，用以轻度查询</li><li><a href="https://chrome.google.com/webstore/detail/grammarly-for-chrome/kbfnbcaeplbcioakkpcpgfkobkghlhen">Grammarly</a>：语法检测。</li></ol>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习仓库</title>
      <link href="/2020/09/06/Java%E5%AD%A6%E4%B9%A0%E4%BB%93%E5%BA%93/"/>
      <url>/2020/09/06/Java%E5%AD%A6%E4%B9%A0%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="中国科学技术大学课程资源"><a href="#中国科学技术大学课程资源" class="headerlink" title="中国科学技术大学课程资源"></a>中国科学技术大学课程资源</h2><p><a href="https://github.com/USTC-Resource/USTC-Course">仓库地址</a></p><h2 id="浙江大学课程攻略共享计划"><a href="#浙江大学课程攻略共享计划" class="headerlink" title="浙江大学课程攻略共享计划"></a>浙江大学课程攻略共享计划</h2><p><a href="https://github.com/QSCTech/zju-icicles">仓库地址</a></p><h2 id="现代-JavaScript-教程"><a href="#现代-JavaScript-教程" class="headerlink" title="现代 JavaScript 教程"></a>现代 JavaScript 教程</h2><p>以最新的 JavaScript 标准为基准。通过简单但足够详细的内容，为你讲解从基础到高阶的 JavaScript 相关知识，</p><p>当前项目已被翻译为多语言。</p><p><a href="https://github.com/javascript-tutorial/zh.javascript.info">仓库地址</a></p><h2 id="JavaScript-算法与数据结构"><a href="#JavaScript-算法与数据结构" class="headerlink" title="JavaScript 算法与数据结构"></a>JavaScript 算法与数据结构</h2><p>本仓库包含了多种基于 JavaScript 的算法与数据结构，每种算法和数据结构都有自己的 README，包含相关说明和链接，同样的也被翻译为多语言</p><p><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/README.zh-CN.md">仓库地址</a></p><h2 id="Nodejs-Roadmap"><a href="#Nodejs-Roadmap" class="headerlink" title="Nodejs-Roadmap"></a>Nodejs-Roadmap</h2><p>这是一个侧重于 Node.js 服务端的开发指南，如果你想进一步学习nodejs的话可以尝试一下</p><p><a href="https://github.com/Q-Angelo/Nodejs-Roadmap">仓库地址</a></p><h2 id="FE-Interview-Questions"><a href="#FE-Interview-Questions" class="headerlink" title="FE-Interview-Questions"></a>FE-Interview-Questions</h2><p>前端面试常考问题整理，按模块知识点分类</p><p><a href="https://blog.poetries.top/FE-Interview-Questions/">文档页面 </a></p><p><a href="https://github.com/poetries/FE-Interview-Questions">仓库地址</a></p><h2 id="JavaScript-进阶问题列表"><a href="#JavaScript-进阶问题列表" class="headerlink" title="JavaScript 进阶问题列表"></a>JavaScript 进阶问题列表</h2><p>从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding<br>面试！作者每周都会在这个仓库下更新的问题，同样的也被翻译为多语言</p><p><a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md">仓库地址</a></p><h2 id="中国科学技术大学课程资源-1"><a href="#中国科学技术大学课程资源-1" class="headerlink" title="中国科学技术大学课程资源"></a>中国科学技术大学课程资源</h2><p><a href="https://github.com/USTC-Resource/USTC-Course">仓库地址</a></p><h2 id="浙江大学课程攻略共享计划-1"><a href="#浙江大学课程攻略共享计划-1" class="headerlink" title="浙江大学课程攻略共享计划"></a>浙江大学课程攻略共享计划</h2><p><a href="https://github.com/QSCTech/zju-icicles">仓库地址</a></p><h2 id="awesome-java-books"><a href="#awesome-java-books" class="headerlink" title="awesome-java-books"></a>awesome-java-books</h2><p>如果你想知道学习应该看什么书籍，关注这个仓库就对了，作者把不同阶段不同知识点的书籍都列了出来</p><p><a href="https://github.com/sorenduan/awesome-java-books">仓库地址</a></p><h2 id="OnJava8"><a href="#OnJava8" class="headerlink" title="OnJava8"></a>OnJava8</h2><p>《On Java 8》中文版，又名《Java编程思想》 第5版 ，一本可以比较系统的学习Java基础的书籍，最重要的是，它是完全免费的</p><p><a href="https://github.com/LingCoder/OnJava8">仓库地址</a></p><p>下面是两个工具类教程</p><h2 id="IntelliJ-IDEA-Tutorial"><a href="#IntelliJ-IDEA-Tutorial" class="headerlink" title="IntelliJ-IDEA-Tutorial"></a>IntelliJ-IDEA-Tutorial</h2><p>初学者对IDEA不太了解的可以看看这个仓库，这也是很多培训班IDEA教程的素材来源</p><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial">仓库地址</a></p><h2 id="Linux-Tutorial"><a href="#Linux-Tutorial" class="headerlink" title="Linux-Tutorial"></a>Linux-Tutorial</h2><p>想要简单的学习一下linux操作可以看看这个仓库，安装和简单的使用足够了</p><p><a href="https://github.com/judasn/Linux-Tutorial">仓库地址</a></p><h2 id="advanced-java"><a href="#advanced-java" class="headerlink" title="advanced-java"></a>advanced-java</h2><p>互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识，后端同学必看，前端同学也可学习</p><p><a href="https://github.com/doocs/advanced-java">仓库地址</a></p><h2 id="java-design-patterns"><a href="#java-design-patterns" class="headerlink" title="java-design-patterns"></a>java-design-patterns</h2><p>学习Java设计模式必看，对新人不太友好的地方就是它是英文的</p><p><a href="https://github.com/iluwatar/java-design-patterns">仓库地址</a></p><h2 id="The-Algorithms-Java"><a href="#The-Algorithms-Java" class="headerlink" title="The Algorithms - Java"></a>The Algorithms - Java</h2><p>使用Java语言的算法教程，同样它也是英文的</p><p><a href="https://github.com/TheAlgorithms/Java">仓库地址</a></p><p>然后是几个关于spring学习的仓库</p><h2 id="spring-boot-demo"><a href="#spring-boot-demo" class="headerlink" title="spring-boot-demo"></a>spring-boot-demo</h2><p>spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 65 个集成demo</p><p><a href="https://github.com/xkcoding/spring-boot-demo">仓库地址</a></p><h2 id="SpringCloudLearning"><a href="#SpringCloudLearning" class="headerlink" title="SpringCloudLearning"></a>SpringCloudLearning</h2><p>方志朋史上最简单的Spring Cloud教程源码</p><p><a href="https://github.com/forezp/SpringCloudLearning">仓库地址</a></p><h2 id="SpringCloud-Learning"><a href="#SpringCloud-Learning" class="headerlink" title="SpringCloud-Learning"></a>SpringCloud-Learning</h2><p>Spring Cloud基础教程，持续连载更新中</p><p><a href="https://github.com/dyc87112/SpringCloud-Learning">仓库地址</a></p><h2 id="mall-learning"><a href="#mall-learning" class="headerlink" title="mall-learning"></a>mall-learning</h2><p>第三个项目是 mall-learning ，这是拥有 35k+star 的mall项目搭配的学习教程，值得推荐</p><p><a href="https://github.com/macrozheng/mall-learning">仓库地址</a></p><p>然后是面试的项目，这类的项目很多，推荐两个最火的</p><h2 id="JavaGuide"><a href="#JavaGuide" class="headerlink" title="JavaGuide"></a>JavaGuide</h2><p><a href="https://github.com/Snailclimb/JavaGuide">仓库地址</a></p><p>「Java学习+面试指南」一份涵盖大部分Java程序员所需要掌握的核心知识,我找工作的时候这个仓库帮助我不要太多，guide哥牛逼</p><h2 id="CS-Notes"><a href="#CS-Notes" class="headerlink" title="CS-Notes"></a>CS-Notes</h2><p><a href="https://github.com/CyC2018/CS-Notes">仓库地址</a></p><p>技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计、Java、Python、C++都有，值得收藏</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps Developer - Roadmaps</title>
      <link href="/2019/09/23/DevOps%20Developer%20-%20Roadmaps/"/>
      <url>/2019/09/23/DevOps%20Developer%20-%20Roadmaps/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自<a href="https://roadmap.sh/devops">https://roadmap.sh/devops</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://roadmap.sh/roadmaps/devops.png" alt="DevOps Developer"></p>]]></content>
      
      
      <categories>
          
          <category> Roadmaps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Backend Developer - Roadmaps</title>
      <link href="/2019/09/23/Backend%20Developer%20-%20Roadmaps/"/>
      <url>/2019/09/23/Backend%20Developer%20-%20Roadmaps/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自<a href="https://roadmap.sh/backend">https://roadmap.sh/backend</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://roadmap.sh/roadmaps/backend.png" alt="Backend Developer"></p>]]></content>
      
      
      <categories>
          
          <category> Roadmaps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Backend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frontend Developer - Roadmaps</title>
      <link href="/2019/09/23/Frontend%20Developer%20-%20Roadmaps/"/>
      <url>/2019/09/23/Frontend%20Developer%20-%20Roadmaps/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自<a href="https://roadmap.sh/frontend">https://roadmap.sh/frontend</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://roadmap.sh/roadmaps/frontend.png" alt="Frontend Developer"></p>]]></content>
      
      
      <categories>
          
          <category> Roadmaps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frontend </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
